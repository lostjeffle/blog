title:'Waitqueue'
## Waitqueue


等待队列本质上是一个双向链表，由等待队列头与等待队列节点构成

等待队列通常用于进程的睡眠等待，当进程进入睡眠状态时，通常为该进程分配一个等待队列节点，将睡眠进程保存到等待队列节点中，之后将该节点添加到特定等待队列（即等待队列头）中；之后当睡眠进程等待的事件发生时，就可以通过等待队列找到并唤醒睡眠进程


### Concept

#### wait queue head

wait_queue_head 抽象等待队列头，即等待队列

```c
struct wait_queue_head {
	spinlock_t		lock;
	struct list_head	head;
};
typedef struct wait_queue_head wait_queue_head_t;
```

@head 链表即用于组织在该等待队列中睡眠的进程


#### wait queue node

wait_queue_entry 抽象等待队列节点，通常每个等待的进程对应一个节点

```c
struct wait_queue_entry {
	unsigned int		flags;
	void			*private;
	wait_queue_func_t	func;
	struct list_head	entry;
};
```

当睡眠进程被唤醒时就会执行 @func 回调函数

@private 私有数据指针，通常指向对应的睡眠进程的 task_struct

```sh
init_wait
    wait->private = current;
    wait->func = autoremove_wake_function;
```


### API

等待队列的调用者主要分为 waiter 与 waker 两类

#### Wait

waiter 部分的 API 主要分为两类

##### wait event

```sh
wait_event_*(wq, condition)
```

第一类是当前进程在等待队列 @wq 上睡眠等待，直到该进程被唤醒，同时期待的 event (即 @condition 为真) 发生

这一类接口的特点是，睡眠进程被 waker 唤醒时，还需要检查条件 @condition 是否为真，若 @condition 条件为真，则进程退出等待状态，否则该进程将再次进入睡眠状态


这类接口的一般流程是

```sh
wait_event_*(wq, condition)
    for (;;) {
        if @condition == True: return
    
        set_current_state(@taks_state) // e.g. TASK_INTERRUPTIBLE
        
        @cmd // @cmd is empty most times
        schedule()
    }
```


waitqueue 框架实现了一系列 wait_event_*() 接口，以实现不同的功能

1. 等待进程的进程状态 @taks_stat，可以为 TASK_INTERRUPTIBLE 即进程的睡眠状态可以被信号中断、TASK_UNINTERRUPTIBLE 即进程的睡眠状态不可以被信号中断、TASK_KILLABLE 即进程的睡眠状态只能被一些致命信号中断
2. 是否存在超时限制，其中定时功能的实现包括基于 jiffies 的 timer、基于 ktime_t 的 hrtimer 两种
3. 按照睡眠进程的排他性，睡眠进程可以为 exclusive 进程或 non-exclusive 进程
4. 每次等待进程被唤醒后是否使用自旋锁对 @condition 条件的检查过程进行保护，其中上锁过程包括 spin_lock() 与 spin_lock_irq() 两种，同时使用的自旋锁又包括等待队列自身的自旋锁以及用户定义的自旋锁两种
5. 用户可以传入自定义的 @cmd 命令以在进程进入睡眠前执行，@cmd 命令默认为空


函数 | 进程状态 | 超时限制 | 排他性 | 自旋锁保护 | cmd | 返回值
---- | ---- | ---- | ---- | ---- | ---- | ----
wait_event | TASK_UNINTERRUPTIBLE | 无 | 无 | 无 | 无 | 函数返回值为 void，即该函数没有返回值
wait_event_interruptible | TASK_INTERRUPTIBLE (能被信号中断) | 无 | 无 | 无 | 无 | 0, 等待的 event 发生；-ERESTARTSYS, 睡眠过程被信号中断
wait_event_killable | TASK_KILLABLE (只能被一些致命信号中断) | 无 | 无 | 无 | 无 | 0, 等待的 event 发生；-ERESTARTSYS, 睡眠过程被信号中断
wait_event_interruptible_exclusive | TASK_INTERRUPTIBLE | 无 | exclusive | 无 | 无 | 0, 等待的 event 发生；-ERESTARTSYS, 睡眠过程被信号中断
| |
wait_event_timeout | TASK_UNINTERRUPTIBLE | timer，超时时间为 @timeout，以 jiffies 为单位 | 无 | 无 | 无 | 剩余的 jiffies 数（至少为 1）等待的 event 发生；0，超时
wait_event_interruptible_timeout | TASK_INTERRUPTIBLE | timer，超时时间为 timeout，以 jiffies 为单位 | 无 | 无 | 无 | 剩余的 jiffies 数（至少为 1），等待的 event 发生；0，超时；-ERESTARTSYS，睡眠过程被信号中断
| |
wait_event_hrtimeout | TASK_UNINTERRUPTIBLE | hrtimer，超时时间为 timeout，为 ktime_t 数据类型 | 无 | 无 | 无 | 0，等待的 event 发生；-ETIME，超时
wait_event_interruptible_hrtimeout | TASK_INTERRUPTIBLE | hrtimer，超时时间为 timeout，为 ktime_t 数据类型 | 无 | 无 | 无 | 0，等待的 event 发生；-ETIME，超时；-ERESTARTSYS，睡眠过程被信号中断
| |
wait_event_interruptible_locked | TASK_INTERRUPTIBLE | 无 | 无 | 等待队列自身的自旋锁 @wq->lock，spin_lock()/spin_unlock() | 无 | 0, 等待的 event 发生; -ERESTARTSYS, 睡眠过程被信号中断
wait_event_interruptible_locked_irq | TASK_INTERRUPTIBLE | 无 | 无 | 等待队列自身的自旋锁 @wq->lock，spin_lock_irq()/spin_unlock_irq() | 无 | 0, 等待的 event 发生；-ERESTARTSYS, 睡眠过程被信号中断
wait_event_interruptible_exclusive_locked | TASK_INTERRUPTIBLE | 无 | exclusive | 等待队列自身的自旋锁 @wq->lock，spin_lock()/spin_unlock() | 无 | 0, 等待的 event 发生；-ERESTARTSYS, 睡眠过程被信号中断
wait_event_interruptible_exclusive_locked_irq | TASK_INTERRUPTIBLE | 无 | exclusive | 等待队列自身的自旋锁 @wq->lock，spin_lock_irq()/spin_unlock_irq() | 无 | 0, 等待的 event 发生；-ERESTARTSYS, 睡眠过程被信号中断
| |
wait_event_lock_irq | TASK_UNINTERRUPTIBLE | 无 | 无 | 用户自己传入的自旋锁 @lock，spin_lock_irq()/spin_unlock_irq() | 无 | 函数返回值为 void，即该函数没有返回值
wait_event_interruptible_lock_irq | TASK_INTERRUPTIBLE | 无 | 无 | 用户自己传入的自旋锁 @lock，spin_lock_irq()/spin_unlock_irq() | 无 | 0, 等待的 event 发生；-ERESTARTSYS, 睡眠过程被信号中断
wait_event_interruptible_lock_irq_timeout | TASK_INTERRUPTIBLE | 超时时间为 timeout，以 jiffies 为单位 | 无 | 用户自己传入的自旋锁 @lock，spin_lock_irq()/spin_unlock_irq() | 无 | 剩余的 jiffies 数（至少为 1），等待的 event 发生；0，超时；-ERESTARTSYS，睡眠过程被信号中断
| |
wait_event_lock_irq_cmd | TASK_UNINTERRUPTIBLE | 无 | 无 | 用户自己传入的自旋锁 @lock，spin_lock_irq()/spin_unlock_irq() | 用户自己传入的 cmd 命令 | 函数返回值为 void，即该函数没有返回值
wait_event_interruptible_lock_irq_cmd| TASK_INTERRUPTIBLE | 无 | 无 | 用户自己传入的自旋锁 @lock，spin_lock_irq()/spin_unlock_irq() | 用户自己传入的 cmd 命令 | 0, 等待的 event 发生；-ERESTARTSYS, 睡眠过程被信号中断


> lock-protected condition check

wait_event_*_locked() 这类接口，每次当睡眠进程被唤醒进行 @condition 检查时，会调用 spin_lock()/spin_unlock() 使用等待队列的自旋锁 @wq->lock 对检查过程进行保护；此时相应地，waker 应该调用 wake_up_locked() 进行唤醒操作

```c
struct wait_queue_head {
	spinlock_t		lock;
	...
};
```

```sh
wait_event_*(wq, condition)
    for (;;) {
        # lock
        if @condition == True: return
        # unlock
    
        set_current_state(@taks_state) // @task_state is like TASK_INTERRUPTIBLE
        
        @cmd // @cmd is schedule() most times
    }
```

##### wait exclusive

另一类接口是 prepare_to_wait_exclusive()

```sh
init_wait(entry)
prepare_to_wait_exclusive(wq, entry, TASK_UNINTERRUPTIBLE)
schedule();
finish_wait(wq, entry);
```

其中 prepare_to_wait_exclusive() 将当前进程对应的等待节点 @entry 添加到等待队列 @wq 中，并将当前进程设置为相应状态 (例如 TASK_UNINTERRUPTIBLE)，之后的 schedule() 就会使得当前进程让出调度器，并进入对应的 @state 状态，直到之后被 waker 唤醒，被唤醒之后会调用 finish_wait() 执行相应的清理工作，例如将睡眠进程恢复为 TASK_RUNNING 状态、将等待节点从等待队列中移除


#### Wake

workqueue core 提供一系列 wake_up_*(x) 接口唤醒在等待队列中睡眠的所有等待进程

1. 只唤醒等待队列中特定进程状态的等待进程，可以为 TASK_INTERRUPTIBLE 或 TASK_UNINTERRUPTIBLE
2. 唤醒的 exclusive 进程的数量
3. 唤醒的等待进程是否上锁，即 wait_up_\*\_locked() 接口用于唤醒 wai_event_*_locked() 接口对应的等待进程


wake_up_*() 接口的处理流程一般是

```sh
wake_up_*()
    (for each waitqueue entry in the waitqueue)
        ret = entry->func(entry, mode, wake_flags, key)
            ret = try_to_wake_up(entry->private, mode, wake_flags)
            if (ret) list_del_init(entry->entry)
        
        if (ret < 0): break
        if (ret && (entry->flags & WQ_FLAG_EXCLUSIVE) && !--nr_exclusive): break
```

即遍历等待队列中的所有等待节点，调用节点对应的 @func() 回调函数，该回调函数一般实现为 autoremove_wake_function()，其中只是通过 wake_up() 唤醒其对应的睡眠等待的进程


等待节点的 @func() 回调函数的原型如下

```c
typedef int (*wait_queue_func_t)(struct wait_queue_entry *wq_entry, unsigned mode, int flags, void *key);
```

@mode 参数描述当前唤醒操作只唤醒等待队列上进程状态为 mode 的进程，例如 wake_up_interruptible() 中 @mode 为 TASK_INTERRUPTIBLE，即 wake_up_interruptible() 只希望唤醒 TASK_INTERRUPTIBLE 状态的睡眠进程

@flags 参数会影响唤醒过程中的一些行为，例如 WF_SYNC 标志标明 waker 不能被唤醒的进程抢占

@key 是 wake_up_*() 传入的，给 @func() 回调函数使用的私有数据，一般只有与 @key 匹配的等待进程才会被唤醒，至于 @key 描述什么条件，是由 @func() 回调函数自己解析的


函数的主要工作是唤醒其对应的睡眠等待的进程，返回值大于 0 表明对应的等待进程成功被唤醒 (例如当前等待进程的状态与 @mode 匹配，因而被唤醒)，返回值 0 表明对应的等待进程与当前的唤醒条件不匹配 (例如当前等待进程的状态与 @mode 不匹配)，返回值小于 0 表示唤醒过程中发生了错误，此时 wake_up_*() 必须停止等待节点的遍历并立即返回


函数 | 进程状态 (mode) | nr_exclusive | wake_flags | key | lock-protected
---- | ---- | ---- | ---- | ---- | ----
wake_up | TASK_INTERRUPTIBLE or TASK_UNINTERRUPTIBLE | 1 | 0 | NULL | 无
wake_up_nr | TASK_INTERRUPTIBLE or TASK_UNINTERRUPTIBLE | @nr | 0 | NULL | 无
wake_up_all | TASK_INTERRUPTIBLE or TASK_UNINTERRUPTIBLE | 0 (唤醒所有的排他性进程) | 0 | NULL | 无
| |
wake_up_interruptible | TASK_INTERRUPTIBLE | 1 | 0 | NULL | 无
wake_up_interruptible_nr | TASK_INTERRUPTIBLE | @nr | 0 | NULL | 无
wake_up_interruptible_all | TASK_INTERRUPTIBLE | 0 (唤醒所有的排他性进程) | 0 | NULL | 无
wake_up_interruptible_sync | TASK_INTERRUPTIBLE | WF_SYNC (waker 不能被唤醒的进程抢占) | 0 | NULL | 无
| |
wake_up_locked | TASK_INTERRUPTIBLE or TASK_UNINTERRUPTIBLE | 1 | 0 | NULL | 有 (与 wait_event_*_locked() 这类接口配对使用)
wake_up_all_locked | TASK_INTERRUPTIBLE or TASK_UNINTERRUPTIBLE | 0 (唤醒所有的排他性进程) | 0 | NULL | 有


> exclusive

上表中的 @nr_exclusive 描述一次 wake_up_*() 接口调用时，允许唤醒的排他性 (exclusive) 等待进程的数量

等待节点的 @flags 的 WQ_FLAG_EXCLUSIVE 标志表明该进程被唤醒时具有排他性，prepare_to_wait_exclusive() 和 wait_event\_\*\_exclusive_*() 这类接口添加的等待节点都是 exclusive 属性的

wake_up_*() 执行过程中，最多只能唤醒 @nr_exclusive 个具有 exclusive 属性的等待进程 (可以唤醒的非 exclusive 属性的等待进程的数量不受限制)，@nr_exclusive 为 0 表示可以唤醒的 exclusive 属性的等待进程的数量不受限制，即可以唤醒所有 exclusive 属性的等待进程
