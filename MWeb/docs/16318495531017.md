title:'FUSE - Feature - notify'
## FUSE - Feature - notify


FUSE server 可以向 client 发送 notify message 向 client 通知事件的发生，相当于是向 client 发送一个 FUSE reply

```
server --[notify]--> client 
```

只是此时 FUSE reply 的 @unique 字段必须为 0，以表明当前 reply 实际上是一个 notify message

```c
struct fuse_out_header {
	uint32_t	len;
	int32_t		error;
	uint64_t	unique;
};
```

此时 @error 字段描述触发的事件类型

```c
enum fuse_notify_code {
	FUSE_NOTIFY_POLL   = 1,
	FUSE_NOTIFY_INVAL_INODE = 2,
	FUSE_NOTIFY_INVAL_ENTRY = 3,
	FUSE_NOTIFY_STORE = 4,
	FUSE_NOTIFY_RETRIEVE = 5,
	FUSE_NOTIFY_DELETE = 6,
	FUSE_NOTIFY_CODE_MAX,
};
```

```sh
# write /dev/fuse
f_ops->write_iter(), i.e., fuse_dev_write
    # if fuse_out_header.unique == 0:
        fuse_notify
            # handle events of different types
```


#### FUSE_NOTIFY_INVAL_ENTRY

当 host 上文件的名称或属性 (size/mode, etc.) 发生变化时，例如 host 上执行 rename/modify 操作，host daemon 可以向 client 发送 FUSE_NOTIFY_INVAL_ENTRY notify，以提示文件的名称或属性发生了变化

此时 FUSE reply 的布局为

```
                   args.out_args[0].size        args.out_args[1].size
                    <--------------------------><------------------>
+-------------------+---------------------------+-------------------+
|  fuse_out_header  |fuse_notify_inval_entry_out|    char *name     |
+-------------------+---------------------------+-------------------+
                    ^                           ^                   
                args.out_args[0].value          args.out_args[1].value

```

```c
struct fuse_notify_inval_entry_out {
	uint64_t	parent;
	uint32_t	namelen;
	uint32_t	padding;
};
```

描述对 @parent (inode number) 目录下名为 @name 的文件作 invalidation 操作

```sh
# write /dev/fuse
f_ops->write_iter(), i.e., fuse_dev_write
    # if fuse_out_header.unique == 0:
        fuse_notify
            case FUSE_NOTIFY_INVAL_ENTRY:
            fuse_notify_inval_entry
                fuse_reverse_inval_entry(parent, 0, name)
                    fuse_invalidate_entry(entry)
                        fuse_invalidate_entry_cache(entry)
                            fuse_dentry_settime(entry, 0) // expire the dentry of child
```

其中主要是将该文件的 dentry 标记为超时，这样下次 fuse 文件系统中再对该文件执行 lookup 操作时，检查到文件的 dentry 状态为超时，就会向 host daemon 重新发起 FUSE_LOOKUP 请求，以重新获取文件的名称与属性


#### FUSE_NOTIFY_INVAL_INODE

当 host 上对文件执行 modify 操作时，host daemon 可以向 client 发送 FUSE_NOTIFY_INVAL_INODE notify，以提示文件的内容发生了变化，并指示 client 对文件特定区间内的 page cache 作 invalidation 操作

此时 FUSE reply 的布局为

```
                   args.out_args[0].size
                    <-------------------------->
+-------------------+---------------------------+
|  fuse_out_header  |fuse_notify_inval_inode_out|
+-------------------+---------------------------+
                    ^                                    
                args.out_args[0].value

```

```c
struct fuse_notify_inval_inode_out {
	uint64_t	ino;
	int64_t		off;
	int64_t		len;
};
```

描述对文件 @ino (inode number) 的 address space 中，@off 偏移处起始的，@len 长度区间内的 page cache 作 invalidation 操作

```sh
# write /dev/fuse
f_ops->write_iter(), i.e., fuse_dev_write
    # if fuse_out_header.unique == 0:
        fuse_notify
            case FUSE_NOTIFY_INVAL_INODE:
            fuse_notify_inval_inode
                fuse_reverse_inval_inode(ino, off, len)
                    invalidate_inode_pages2_range // invalidate page cache
```


#### FUSE_NOTIFY_DELETE

FUSE_NOTIFY_DELETE 与之前介绍的 FUSE_NOTIFY_INVAL_ENTRY 类似，用于提示 host 上对应的文件被删除

FUSE_NOTIFY_INVAL_ENTRY notify 并不能很好地处理文件被删除的场景，根据 [FUSE: Notifying the kernel of deletion.](https://github.com/torvalds/linux/commit/451d0f599934fd97faf54a5d7954b518e66192cb) 中的描述，client A/B 共享 host 上的同一个目录，此时 client A 删除文件的场景下，FUSE_NOTIFY_INVAL_ENTRY notify 会将 oldfile 的 dentry 标记为超时状态，这样下次再对该文件执行 lookup 操作的时候，会重新向 host daemon 发起 FUSE_LOOKUP 请求，以重新获取文件的名称与属性，此时 host 上对应路径的文件已经被删除，因而 FUSE_LOOKUP 请求返回后，该 dentry 转变为 negative dentry

之后 client B 创建同名文件，此时 client A 上的另一个进程重新对该文件发起 pathname lookup 操作，此时会找到 client A 中之前的 negative dentry，从而显示该文件不存在

而如果使用 FUSE_NOTIFY_DELETE notify，除了将文件的 dentry 标记为超时之外，同时将该 dentry 从 dcache 中移除，这样 client A 上的其他进程重新对该文件发起 pathname lookup 操作时，就会重新创建一个新的 dentry，并重新向 host daemon 发起 FUSE_LOOKUP 请求，从而获取到 client B 新创建的文件的相关属性，从而规避以上问题

此时 FUSE reply 的布局为

```
                   args.out_args[0].size    args.out_args[1].size
                    <----------------------><------------------>
+-------------------+----------------------+-------------------+
|  fuse_out_header  |fuse_notify_delete_out|    char *name     |
+-------------------+----------------------+-------------------+
                    ^                      ^                   
                args.out_args[0].value     args.out_args[1].value

```

```c
struct fuse_notify_delete_out {
	uint64_t	parent;
	uint64_t	child;
	uint32_t	namelen;
	uint32_t	padding;
};
```

描述 @parent (inode number) 下名为 @name 的文件已经被删除，同时这个被删除的文件的 inode number 为 @child

```sh
# write /dev/fuse
f_ops->write_iter(), i.e., fuse_dev_write
    # if fuse_out_header.unique == 0:
        fuse_notify
            case FUSE_NOTIFY_DELETE:
            fuse_reverse_inval_entry(parent, child, name)
                fuse_invalidate_entry(entry)
                    fuse_invalidate_entry_cache(entry)
                        fuse_dentry_settime(entry, 0) // expire the dentry of child
                d_delete(entry) // delete dentry from dcache
```

这里除了将文件的 dentry 标记为超时，同时将该 dentry 从 dcache 中移除


#### FUSE_NOTIFY_STORE

host daemon 可以向 client 发送 FUSE_NOTIFY_STORE notify，FUSE_NOTIFY_STORE 请求中还包含了一个 data buffer，以指示 client 向 @nodeid 文件的 @offset 偏移处写入 @size 大小的数据，此时这个 data buffer 就紧随在 FUSE_NOTIFY_STORE 请求的 fuse_notify_store_out 之后

```
                   args.out_args[0].size    args.out_args[1].size
                    <----------------------><------------------>
+-------------------+----------------------+-------------------+
|  fuse_out_header  |fuse_notify_store_out |    data buffer    |
+-------------------+----------------------+-------------------+
                    ^                      ^                   
                args.out_args[0].value     args.out_args[1].value

```

```c
struct fuse_notify_store_out {
	uint64_t	nodeid;
	uint64_t	offset;
	uint32_t	size;
	uint32_t	padding;
};
```


client 在接收到 FUSE_NOTIFY_STORE notify 的时候，就会将 FUSE_NOTIFY_STORE 请求附带的 data buffer 中的数据写入对应的 page cache

```sh
# write /dev/fuse
f_ops->write_iter(), i.e., fuse_dev_write
    # if fuse_out_header.unique == 0:
        fuse_notify
            case FUSE_NOTIFY_STORE:
            fuse_notify_store
                for each page in (offset, offset+size):
                    # find page in page cache
                    # copy data from input data buffer to this page
```



#### FUSE_NOTIFY_RETRIEVE

host daemon 可以向 client 发送 FUSE_NOTIFY_RETRIEVE notify，以请求读取 @nodeid 文件的 @offset 偏移处 @size 大小的数据

```
                   args.out_args[0].size
                    <------------------------>
+-------------------+------------------------+
|  fuse_out_header  |fuse_notify_retrieve_out|
+-------------------+------------------------+
                    ^                  
                args.out_args[0].value

```

```c
struct fuse_notify_retrieve_out {
	uint64_t	notify_unique;
	uint64_t	nodeid;
	uint64_t	offset;
	uint32_t	size;
	uint32_t	padding;
};
```

client 在接收到 FUSE_NOTIFY_RETRIEVE notify 的时候，就会读取对应 page cache 中的数据，并将这些数据以 FUSE_NOTIFY_REPLY 请求的形式发送给 server

```sh
# write /dev/fuse
f_ops->write_iter(), i.e., fuse_dev_write
    # if fuse_out_header.unique == 0:
        fuse_notify
            case FUSE_NOTIFY_RETRIEVE:
            fuse_notify_retrieve
                # read page in (offset, offset+size):
                # send FUSE_NOTIFY_REPLY request to server
```
