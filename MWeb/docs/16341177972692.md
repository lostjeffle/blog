title:'FUSE - IO'
## FUSE - IO


### Buffer READ

```sh
f_op->read_iter(kiocb, iov_iter), i.e. fuse_file_read_iter()
    fuse_cache_read_iter
        generic_file_read_iter
            filemap_read
                filemap_get_pages
                    filemap_get_read_batch // find buffer page in page cache
                    filemap_create_page // create new buffer page if not exist
                
                if !PageUptodate(page):
                    filemap_update_page
                        filemap_read_page
                            a_ops->readpage(), i.e. fuse_readpage()
                                fuse_do_readpage
                                    # send FUSE_READ request
```


### Buffer WRITE

fuse 的 buffer write 有两种模式，writethrough 和 writeback

fuse_conn 的 @writeback_cache 标志位描述当前 fuse 文件系统是采用 writethrough 还是 writeback 模式

fuse server/client 可以在 FUSE_INIT 阶段进行协商，如果采用 writeback 模式，那么 fuse server 需要将 @fuse_init_out.flags 字段设置上 FUSE_WRITEBACK_CACHE 标志，否则就采用 writethrough 模式，这也是默认的模式

```c
struct fuse_conn {
	/** write-back cache policy (default is write-through) */
	unsigned writeback_cache:1;
	...
}
```


#### writethrough

writethrough 模式下执行 buffer write 的时候，在将数据写入 page cache 之后，会立即发起 FUSE_WRITE 请求，将这些写入的 page cache 回写到后端

```sh
f_op->write_iter(kiocb, iov_iter), i.e. fuse_file_write_iter()
    fuse_cache_write_iter
        fuse_perform_write
            fuse_fill_write_pages
                page = grab_cache_page_write_begin() // find correspnding page cache
                copy_page_from_iter_atomic(page, ..., iov_iter) // copy data in iov to page cache
            
            fuse_send_write_pages // send FUSE_WRITE request, with page cache
```


#### writeback

writeback 模式下执行 buffer write 的时候，只是将数据写入 page cache

```sh
f_op->write_iter(kiocb, iov_iter), i.e. fuse_file_write_iter()
    fuse_cache_write_iter
        generic_file_write_iter      
            generic_perform_write
                a_ops->write_begin() // find buffer page in page cache
                    iov_iter_copy_from_user_atomic // copy from user buffer to buffer page
                a_ops->write_end() // mark buffer page and inode as dirty
```


之后在 writeback 的时候再发起 FUSE_WRITE 请求，将这些 dirty page cache 回写到后端

```sh
__writeback_single_inode
    do_writepages
        a_ops->writepages(), i.e., fuse_writepages
            # send FUSE_WRITE request
```


### page cache invalidation

fuse 文件系统中，client 和 server、或者多个 client 之间会共用一份目录，双方都可能对目录中的文件进行修改，此时双方就需要对文件的数据进行同步，包括元数据 (文件的各项属性) 与数据 (address space 中的 page cache)

当 client 检测到文件被 server 或其他 client 修改时，就需要更新 client 侧缓存到元数据，同时对文件的整个 page cache 作 invalidation 操作，即将文件 address space 中的所有 page cache 释放掉，这样下次再访问文件数据的时候就会重新向 server 发送 FUSE_READ 请求，以读取文件的最新数据，这一过程就称为 page cache invalidation

需要注意的是，只有在 writethrough 模式下才会发生 page cache invalidation，而在 writeback 模式下，client 侧会完全信任 client 自己缓存的文件属性，而不会相信 server 返回的文件属性

在 writethrough 模式下，client 侧则是完全信任 server 返回的文件属性，当 client 看到的文件属性和 fuse server 返回的文件属性不一样时，说明 server 侧可能对文件进行了修改，此时 client 就会执行 page cache invalidation 操作


page cache invalidation 有以下三种模式


#### default

fuse_change_attributes() 是执行 page cache invalidation 的入口

在默认模式下 (即没有开启 auto_inval_data 和 explicit_inval_data)，当两边看到的文件大小 (size) 不一致时，会对该文件执行 page cache invalidation 操作

```sh
fuse_change_attributes
    if oldsize != attr->size:
        invalidate_inode_pages2 // invalidate all page cache
```

此时 page cache invalidation 的入口有

1. dentry revalidation

fuse 在执行 pathname lookup 操作时会向 server 发送 FUSE_LOOKUP 请求，而返回的 reply 中就会包含该文件的元数据信息

```sh
# slow path
path_lookupat
    link_path_walk
        walk_component
            lookup_slow
                dir->lookup(), i.e., fuse_lookup
                    fuse_lookup_name
                        fuse_simple_request // send FUSE_LOOKUP request
                        fuse_iget
                            fuse_init_inode
                            fuse_change_attributes
```

此后当 dentry 发生超时的时候，client 需要重新向 server 发送 FUSE_LOOKUP 请求，此时如果文件最新的元数据与 client 缓存的元数据不一致，就会触发 page cache invalidation

```sh
# fast path
path_lookupat
    link_path_walk
        walk_component
            lookup_fast
                dentry = __d_lookup(parent, &nd->last) // find in dcache
                d_revalidate(dentry, ...)
                    if dentry->d_flags & DCACHE_OP_REVALIDATE:
                        dentry->d_op->d_revalidate(dentry, ...), i.e., fuse_dentry_revalidate() // check dentry timeout expire
                            if jiffies > fuse_dentry->time, i.e., dentry timeout:
                                fuse_simple_request // send FUSE_LOOKUP request
                                fuse_change_attributes
```


2. read past EOF

read 路径中，发生 read past EOF 的时候，会向 server 发送 FUSE_GETATTR 请求，以更新文件的 i_size 属性，这一过程中如果文件的元数据发生变化，也会触发 page cache invalidation

```sh
.read_iter(), i.e. fuse_file_read_iter
    fuse_cache_read_iter
        # if read past EOF (to ensure i_size is up to date)
            fuse_update_attributes
                fuse_update_get_attr
                    fuse_do_getattr
                        # send FUSE_GETATTR request
                        fuse_change_attributes
```


#### auto_inval_data

fuse 可以配置为 auto_inval_data 模式，此时依赖于 client 在执行一些需要依赖元数据的操作的时候，向 server 发送 FUSE_GETATTR 请求以查询文件最新的元数据，如果查询到的最新的元数据与 client 之前缓存的元数据存在差异 (例如文件的大小 attr->size、文件数据最近一次的修改时间 attr->mtime)，那么就会执行 page cache invalidation 操作

在 auto invalidation 模式下，和默认模式下一样，当两边看到的文件大小 (size) 不一致时，会对该文件执行 page cache invalidation 操作

同时在此基础上，当两边看到的文件大小 (size) 一致、但文件数据最近一次的修改时间 (mtime) 不一致时，就会触发 page cache invalidation

```sh
fuse_change_attributes
    if oldsize == attr->size:
        old_mtime = inode->i_mtime
        new_mtime = attr->mtime
        if old_mtime != new_mtime:
            invalidate_inode_pages2 // invalidate all page cache
```


auto_inval_data 的入口有

1. dentry revalidation

2. always update attributes on read

auto_inval_data 模式下，每次 buffered read 的时候，每隔 attr_timeout 周期触发一次 page cache invalidation

```sh
.read_iter(), i.e. fuse_file_read_iter
    fuse_cache_read_iter
        # if fc->auto_inval_data: (always update attributes on read)
            fuse_update_attributes
                fuse_update_get_attr
                    fuse_do_getattr
                        # send FUSE_GETATTR request
                        fuse_change_attributes
```


fuse_conn 的 @auto_inval_data 标志位描述当前 fuse 文件系统是否启用 automatic page cache invalidation 模式

fuse server/client 可以在 FUSE_INIT 阶段进行协商，如果开启 automatic page cache invalidation 模式，那么 fuse server 需要将 @fuse_init_out.flags 字段设置上 FUSE_AUTO_INVAL_DATA 标志

```c
struct fuse_conn {
	/** Use enhanced/automatic page cache invalidation. */
	unsigned auto_inval_data:1;
	...
}
```

virtiofsd 一般默认开启 auto_inval_data 模式


#### explicit_inval_data

在 explicit invalidation 模式下，由 client 自己全权负责是否或者什么时候对文件执行 page cache invalidation 操作

之前介绍过默认模式下，当两边看到的文件大小 (size) 不一致时，会对该文件执行 page cache invalidation 操作

因而只要 server 对文件进行了修改，只要文件的大小发生了变化，即使文件大小发生的变化可能很小，而整个文件可能很大，client 侧都会对整个文件执行 page cache invalidation 操作，也就是说这种场景下 page cache invalidation 代价非常大

后面 fuse 支持 FUSE_NOTIFY_INVAL_INODE notify，即 server 对文件执行修改操作时，server 可以向 client 发送 FUSE_NOTIFY_INVAL_INODE notify，以提示文件的内容发生了变化，并指示 client 对文件特定区间内的 page cache 作 invalidation 操作，此时 client 只需要对特定区间的 page cache 作 invalidation 操作，而无需对整个文件执行 page cache invalidation 操作

因而对于支持 FUSE_NOTIFY_INVAL_INODE notify 的 fuse server 来说，可以使用 explicit invalidation 模式，此时 client 在接收到 server 返回的文件的最新属性时，当两边看到的文件大小 (size) 不一致时，client 不会对该文件执行 page cache invalidation 操作，而是依赖于 server 发送的 FUSE_NOTIFY_INVAL_INODE notify 对发生变化的特定区间内的 page cache 作精准的 invalidation 操作

参考 [fuse: allow filesystems to have precise control over data cache](https://github.com/torvalds/linux/commit/ad2ba64dd489805e7ddf5fecf166cae1e09fc5c0)

```sh
fuse_change_attributes
    if oldsize != attr->size:
        if !fc->explicit_inval_data:
            invalidate_inode_pages2 // invalidate all page cache
```


fuse_conn 的 @explicit_inval_data 标志位描述当前 fuse 文件系统是否启用 automatic page cache invalidation 特性

fuse server/client 可以在 FUSE_INIT 阶段进行协商，如果开启 explicit page cache invalidation 特性，那么 fuse server 需要将 @fuse_init_out.flags 字段设置上 FUSE_EXPLICIT_INVAL_DATA 标志

```c
struct fuse_conn {
	/** Filesystem is fully responsible for page cache invalidation. */
	unsigned explicit_inval_data:1;
	...
}
```


#### update attribute

之前介绍过，client 在执行一些依赖于元数据的操作的时候，会向 server 发送 FUSE_GETATTR 请求，以更新文件的元数据，这一过程中如果文件的元数据发生变化，就会触发 page cache invalidation，其入口为 fuse_update_attributes()

```sh
fuse_update_attributes(..., request_mask, flags)
```

@request_mask 描述调用者当前需要查询文件的哪些属性


一般情况下会复用 client 侧缓存的元数据，只有当 attr 超时的时候，才会重新向 server 发送 FUSE_GETATTR 请求

```sh
fuse_update_attributes(..., request_mask, flags)
    fuse_update_get_attr
        sync = time_before64(fi->i_time, get_jiffies_64())
        # if sync:
            fuse_do_getattr
                # send FUSE_GETATTR request
                fuse_change_attributes
```

pathname lookup 过程中，FUSE_LOOKUP 返回的 reply 中，@attr_valid/@attr_valid_nsec 就描述了这些文件元数据的超时时间

```sh
# slow path
path_lookupat
    link_path_walk
        walk_component
            lookup_slow
                dir->lookup(), i.e., fuse_lookup
                    fuse_lookup_name
                        fuse_simple_request // send FUSE_LOOKUP request
                        fuse_iget
                            fuse_change_attributes
                                fuse_change_attributes_common
                                    fi->i_time = attr_valid // from @fuse_entry_out.attr_valid/attr_valid_nsec                                
```


但是调用者也可以通过设置对应文件的 @inval_mask 标志位，或在传入的 @flags 参数中设置 AT_STATX_FORCE_SYNC 标志，从而强制向 server 发送 FUSE_GETATTR 请求

```sh
fuse_update_attributes(..., request_mask, flags)
    fuse_update_get_attr
        # if (flags & AT_STATX_FORCE_SYNC): sync = true
        # if (@request_mask & fi->inval_mask): sync = true
        
        # if sync:
            fuse_do_getattr
                # send FUSE_GETATTR request
                fuse_change_attributes
```


### Tunable

#### max_pages

一开始一个 FUSE_READ/FUSE_WRITE 请求 (包括 buffer/direct IO) 可以包含的 page 的数量是有限的，其上限为 FUSE_MAX_PAGES_PER_REQ，即单个请求最多只能包含 32 个 page，这个限制最初来源于 struct fuse_req 中内嵌的 page 描述符数组的大小

```c
struct fuse_req {
    ...
    /** page vector */
    struct page *pages[FUSE_MAX_PAGES_PER_REQ];
}
```

v3.9 引入的 commit 4250c0668ea10 ("fuse: general infrastructure for pages[] of variable size") 使得 struct fuse_req 可以包含可变数量的 page 描述符，但是单个 FUSE 请求最多只能包含 32 个 page 的限制仍然存在

```c
struct fuse_req {
	/** page vector */
	struct page **pages;

	/** inline page vector */
	struct page *inline_pages[FUSE_REQ_INLINE_PAGES];

	/** number of pages in vector */
	unsigned num_pages;
	...
}
```


后来 v4.20 引入的 commit 5da784cce430 ("fuse: add max_pages to init_out") 增加的 max_pages 特性，双方可以通过 fuse 协议协商单个 FUSE 请求可以包含的 page 的最大数量

```c
struct fuse_conn {
	/** Maximum number of pages that can be used in a single request */
	unsigned int max_pages;
	
	/** Constrain ->max_pages to this value during feature negotiation */
	unsigned int max_pages_limit;
	...
}
```

在协商过程中，fuse server 必须在 fuse_init_out.flags 字段设置上 FUSE_MAX_PAGES 标记，通过 fuse_init_out.max_pages 协商单个 FUSE 请求可以包含的 page 的最大数量，但是最大不能超过 @max_pages_limit

@max_pages_limit 的默认值为 FUSE_MAX_MAX_PAGES 即 256，即单个 FUSE 请求可以包含的 page 的最大数量为 256，其他文件系统例如 virtiofs 也可以定制自己的 @max_pages_limit 参数

```sh
process_init_reply
    if arg->flags & FUSE_MAX_PAGES:
        fc->max_pages = min_t(fc->max_pages_limit, arg->max_pages)
```


而如果 fuse server 不支持协商，那么单个 FUSE 请求可以包含的 page 的最大数量还是保持为默认的 FUSE_DEFAULT_MAX_PAGES_PER_REQ 即 32


#### max_write

单个 FUSE_WRITE 请求下发的数据大小存在上限

```c
struct fuse_conn {
	/** Maximum write size */
	unsigned max_write;
	...
}
```

fuse server 可以通过 fuse_init_out.max_write 协商这个上限值，但是最小不能小于 4K

```sh
process_init_reply
    fc->max_write = max_t(unsigned, 4096, fc->max_write);
```


在执行 write 操作的时候，单个 FUSE_WRITE 请求最多能够容纳 @max_write 大小的数据，如果当前需要下发的数据超过了 @max_write，那么就需要下发多个 FUSE_WRITE 请求

```sh
# writethrough
f_op->write_iter(kiocb, iov_iter), i.e. fuse_file_write_iter()
    fuse_cache_write_iter
        fuse_perform_write
            while data to write:
                fuse_fill_write_pages // fill FUSE_WRITE request up to @max_write
                fuse_send_write_pages // send FUSE_WRITE request
```


#### max_read

@max_read 描述单个 FUSE_READ 请求最多能够容纳的数据大小

```c
struct fuse_conn {
	/** Maximum read size */
	unsigned max_read;
	...
}
```

一般 fuse 文件系统 @max_read 参数的默认值为 UINT_MAX，即不存在限制，但用户也可以通过 "-o max_read=" 挂载参数来设置这一限制，但是最小不能小于 4K


在执行 read 操作的时候，单个 FUSE_READ 请求最多能够容纳 @max_read 大小的数据，如果当前需要下发的数据超过了 @max_read，那么就需要下发多个 FUSE_READ 请求

```sh
f_op->read_iter(kiocb, iov_iter), i.e. fuse_file_read_iter()
    fuse_direct_read_iter
        __fuse_direct_read
            fuse_direct_io
                while data to read:
                    # fill FUSE_READ request up to @max_read
                    fuse_send_read // send FUSE_WRITE request
```


#### max_readahead

fuse 的 readahead window size 默认为 128KB

```sh
# 4.19
fuse_fill_super
    fuse_bdi_init
        sb->s_bdi->ra_pages = (VM_MAX_READAHEAD * 1024) / PAGE_SIZE;
```

```sh
# 5.10
super_setup_bdi_name
    bdi_alloc()
        bdi->ra_pages = VM_READAHEAD_PAGES;
```


fuse server 可以通过 fuse_init_out.max_readahead 协商 readahead window size

```sh
process_init_reply
    ra_pages = arg->max_readahead / PAGE_SIZE;
```


readahead 过程中，如果 readahead window size 的大小超过了 max_read，就需要发送多个 FUSE_READ 请求

```sh
nr_pages = sb->s_bdi->ra_pages, i.e. 128K
a_ops->readahead(), i.e. fuse_readahead()
    while data to read:
        # fill FUSE_READ request up to @max_read and @max_pages
        fuse_send_readpages // send FUSE_WRITE request
```
