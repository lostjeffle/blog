title:'Feature - readahead'
## Feature - readahead

### readahead window

readahead window size 由 bdi->ra_pages 描述，以 page 为单位

```c
struct backing_dev_info {
	unsigned long ra_pages;	/* max readahead in PAGE_SIZE units */
	...
}
```

bdi 最初在 request_queue->backing_dev_info 字段中分配

```sh
blk_alloc_queue
    q->backing_dev_info = bdi_alloc()
```

之后传递给 bdev->bd_bdi

```sh
bdev_alloc_inode
    ei->bdev.bd_bdi = &noop_backing_dev_info;

blkdev_get_by_dev
    __blkdev_get
        if (bdev->bd_bdi == &noop_backing_dev_info)
            bdev->bd_bdi = bdi_get(disk->queue->backing_dev_info);
```

再传递给 sb->s_bdi

```sh
ext4_mount
    mount_bdev
        sget
            set_bdev_super
                s->s_bdi = bdi_get(s->s_bdev->bd_bdi);
```


#### readahead window size

readahead window size 默认为 VM_READAHEAD_PAGES 即 128KB

```sh
blk_alloc_queue
    q->backing_dev_info = bdi_alloc()
        bdi->ra_pages = VM_READAHEAD_PAGES;
```


v5.10 引入的 commit c2e4cd57cfa1 ("block: lift setting the readahead size into the block layer")，使得 readahead window size 为 @io_opt 的两倍

```
blk_queue_io_opt
    q->backing_dev_info->ra_pages = max(queue_io_opt(q) * 2 / PAGE_SIZE, VM_READAHEAD_PAGES);
```

用户可以通过 `/sys/block/<dev>/queue/read_ahead_kb` 读取或设置 readahead window size


#### readahead window size in file_ra_state

readahead 路径中使用 struct file_ra_state 描述相关参数

```c
struct file_ra_state {
	unsigned int ra_pages;
	...
};
```

其中 @ra_pages 就描述 readahead window size，实际上就来自对应的 bdi->ra_pages 参数

```sh
sys_open
    do_sys_open
        do_filp_open
            path_openat
                do_last
                    vfs_open
                        do_dentry_open
                            file_ra_state_init
                                f->f_ra->ra_pages = inode_to_bdi(mapping->host)->ra_pages, i.e., sb->s_bdi->ra_pages
```


### read page routine

readahead 的入口为 do_page_cache_ra()

```c
void do_page_cache_ra(struct readahead_control *ractl,
		unsigned long nr_to_read, unsigned long lookahead_size)
```

struct readahead_control 描述一个 readahead 请求，do_page_cache_ra() 函数描述对 rac.file 文件执行 readahead 操作，其 readahead window 如下所示

```
                              |<- @lookahead_size -|
                                    (ra.async_size)
|----------------- @nr_to_read ----------------->|
                    (ra.size)
|==============================#=================|
^                              ^page marked with PG_readahead
rac._index
(ra.start)
```

```sh        
do_page_cache_ra(rac, nr_to_read, lookahead_size)
    page_cache_ra_unbounded
        # mark page at offset (nr_to_read - lookahead_size) with PG_readahead
        
        # read all pages in readahead window
        read_pages
            aops->readahead()/readpages()/readpage(), i.e., ext4_readahead
```


#### .readpages()

a_ops 的 .readpages() 可以用于将 readahead window 内的所有 page 从磁盘读到内存中

```c
	int (*readpages)(struct file *filp, struct address_space *mapping,
			struct list_head *pages, unsigned nr_pages);
```

@pages 链表就组织了该 readahead window 中的所有 page，其数量为 @nr_pages

```sh        
do_page_cache_ra(rac, nr_to_read, lookahead_size)
    page_cache_ra_unbounded
        # mark PG_readahead ...
        
        # for each page in readahead window
            add this page into a local list &page_pool
            ractl->_nr_pages++
        
        read_pages
            aops->readpages(..., &page_pool, rac->_nr_pages)
```


#### .readpage()

当 readpages()/readahead() 回调函数均未定义时，会回退到调用 a_ops 的 .readpage() 来将 readahead window 内的所有 page 从磁盘读到内存中

此时会对于 readahead window 内的每个 page 调用一次 .readpage() 回调函数

```c
	int (*readpage)(struct file *, struct page *);
```

```sh        
do_page_cache_ra(rac, nr_to_read, lookahead_size)
    page_cache_ra_unbounded
        # mark PG_readahead ...
        
        read_pages
            # for each page in readahead window
                aops->readpage(..., page)
```

#### .readahead()

readahead 路径会优先调用 a_ops 的 .readahead() 来将 readahead window 内的所有 page 从磁盘读到内存中

```c
void (*readahead)(struct readahead_control *rac);
```

传入的 rac 就描述了 readahead window

```
|----------------- @rac->_nr_pages ------------->|
                    (@nr_to_read)
|================================================|
^
rac._index
(ra.start)
```

```sh        
do_page_cache_ra(rac, nr_to_read, lookahead_size)
    page_cache_ra_unbounded
        # mark PG_readahead ...
        
        read_pages
            aops->readahead(rac)
                # for each page in readahead window
                page = readahead_page(rac)
                
                # handle this page ...
```


iomap 框架提供了 iomap_readahead() 来实现 .readahead() 回调函数

```c
void iomap_readahead(struct readahead_control *rac, const struct iomap_ops *ops)
```


### Entry Routine

#### file memory mapping

下面以 file memory mapping 为例介绍 readahead 路径，readahead 实际包含 sync readahead 与 async readahead 两种

##### sync readahead

page fault 路径中会首先到 page cache 中查找当前触发 page fault 的地址对应的 page，如果 page cache 中找不到对应的 page (例如 mmap 之后第一次访问)，那么就会触发 sync readahead

```sh
filemap_fault
    find_get_page   // find page in page cache
    (find no page) do_sync_mmap_readahead
        ra->size = ra->ra_pages;
        ra->async_size = ra->ra_pages / 4;
        rac._index = ra->start = vmf->pgoff - ra->ra_pages / 2;
        
        do_page_cache_ra(&ractl, ra->size, ra->async_size)
```


此时 readahead window 如下所示，即以 @pgoff (当前触发 page fault 即当前访问的文件偏移) 为中点构造一个 @ra_pages 大小的 readahead window，当然这个 readahead window 不会超过文件大小的边界

```
                               |<- @lookahead_size -|
                                (ra.async_size, i.e. ra->ra_pages / 4)
|----------------- @nr_to_read -------------------->|
                (ra.size, i.e. ra->ra_pages)
|=============================#=====================|
^                    ^pgoff   ^page marked with PG_readahead
rac._index
(ra.start, i.e. pgoff - ra_pages/2)
```

同时 readahead window 往前 @async_size 偏移处对应的**一个** page 会被标记为 PG_readahead，这个标记就与之后的 async readahead 相关

目前实现的 async readahead 算法中，@async_size 为 (readahead window size)/4


##### async readahead

上述 sync readahead 路径中，readahead window 往前 @async_size 偏移处对应的**一个** page 会被标记为 PG_readahead，这个标记就与之后的 async readahead 相关

之后当这个标记为 PG_readahead 的 page 触发 page fault 的时候，就会触发 async readahead

```sh
filemap_fault
    find_get_page   // find page in page cache
    (find page) do_async_mmap_readahead
        (if PageReadahead(page)) page_cache_async_readahead
            page_cache_async_ra
                ClearPageReadahead(page);
                ondemand_readahead
                    # It's the expected callback index, assume sequential access.
                    do_page_cache_ra(&ractl, ra->size, ra->async_size)
                        ...
```

此时新一轮的 readahead window 为

```
             |<-------------- @lookahead_size --------------|
                    (ra.async_size, i.e. ra->ra_pages)
    
             |---------------- @nr_to_read ---------------->|
                        (ra.size, i.e. ra->ra_pages)
|=====#=====||#=============================================|
      ^pgoff  ^page marked with PG_readahead
             ^
              rac._index
              (ra.start, i.e. first page after previous readahead window)
              
              <-------------- readahead window ------------->
```

即从上一轮的 readahead window 之后，构造一个 @ra_pages 大小的 readahead window，此时新一轮 readahead window 的第一个 page 就会被标记为 PG_readahead


#### buffer read

##### sync readahead

> initial_readahead

如果一开始 initial READ 是从 0 file offset 处开始的，那么

```sh
filemap_read
    filemap_get_pages
        filemap_get_read_batch  // find page cache
        (find no page) page_cache_sync_readahead
            page_cache_sync_ra
                ondemand_readahead
                    # initial_readahead
                    ra->start = 0
                    ra->size = get_init_ra_size() // ramp window size from iter->count
                    ra->async_size = ra->size - req_size
                    do_page_cache_ra(rac, iter->count, 0) 
    
```

此时 readahead window 为

```
|----- current READ size ---->|<- @lookahead_size -|
         (iter->count)      (ra.async_size, i.e. ra.size - iter->count)

|----------------- @nr_to_read -------------------->|
        (ra.size, i.e. multiples of iter->count)
|=============================#=====================|
^                             ^page marked with PG_readahead
rac._index
(iocb->ki_pos, i.e. 0)
```

此时 readahead window 的大小是当前 READ 操作需要读取的 page 数量的整数倍 (但是不能超过 ra->ra_pages)

同时将这个 readahead window 中，当前 READ 操作需要读取的 page 数量之后的第一个 page 标记为 PG_readahead，以用于之后的 async readahead


> standalone, small random read

而如果一开始 initial READ 是从 non-0 file offset 处开始的，那么当前的 READ 操作会被认定为是 small random read

```sh
filemap_read
    filemap_get_pages
        filemap_get_read_batch  // find page cache
        (find no page) page_cache_sync_readahead
            page_cache_sync_ra
                ondemand_readahead
                    # standalone, small random read
                    # Read as is, and do not pollute the readahead state.
                    do_page_cache_ra(rac, iter->count, 0)
    
```

此时 readahead window 为

```                             
|----------------- @nr_to_read -------------------->|
            (current READ, i.e. iter->count)
|===================================================|
^
rac._index
(iocb->ki_pos)
```

此时这个 readahead window 只是覆盖当前 READ 需要读取的 page，并不会读取额外的 page，同时 @lookahead_size 为 0，也就是此时并不存在 readahead 的语义


在 initial READ 之后的 sequential READ 在触发 readahead 算法的时候，一样只是被认定为 small random read，而随着这种 sequential READ 的累积，直到过去累积的连续 sequential READ 的长度超过当前 READ 需要读取的 page 数量 (iter->count) 时，

```sh
filemap_read
    filemap_get_pages
        filemap_get_read_batch  // find page cache
        (find no page) page_cache_sync_readahead
            page_cache_sync_ra
                ondemand_readahead
                    try_context_readahead
                        # if length of the past sequential read sequence exceeds current READ size (iter->count)
                        ra->start = iocb->ki_pos
                        ra->size = current READ size (iter->count), adds length of the past sequential read sequence
                        ra->async_size = 1
                    do_page_cache_ra(rac, ra->size, ra->async_size)
    
```

此时 readahead window 为

```
|--- current READ size --->|<-----------------------|
        (iter->count)      (length of the past sequential read sequence)

|----------------- @nr_to_read -------------------->|
        (ra.size, i.e. multiples of iter->count)
|==================================================#|
^                                                  ^PG_readahead
rac._index
(iocb->ki_pos)
```

此时 readahead window 的大小是当前 READ 操作需要读取的 page 数量，加上查询到的过去累积的连续 sequential READ 的长度 (但是不能超过 ra->ra_pages)

同时将这个 readahead window 中的最后一个 page 标记为 PG_readahead，以用于之后的 async readahead


##### async readahead

```sh
filemap_read
    filemap_get_pages
        filemap_get_read_batch  // find page cache
        (found，and hit PG_readahead) filemap_readahead
            page_cache_async_ra
                ondemand_readahead
                    # It's the expected callback index, assume sequential access.
                    do_page_cache_ra(rac, ra->size, ra->async_size)
    
```

此时新一轮的 readahead window 为

```
             |<-------------- @lookahead_size --------------|
                    (ra.async_size, i.e. ra->ra_pages)
    
             |---------------- @nr_to_read ---------------->|
                        (ra.size, i.e. ra->ra_pages)
|=====#=====||#=============================================|
      ^       ^page marked with PG_readahead
iocb->ki_pos
             ^
              rac._index
              (ra.start, i.e. first page after previous readahead window)
              
              <-------------- readahead window ------------->
```

即从上一轮的 readahead window 之后，构造一个 @ra_pages 大小的 readahead window，此时新一轮 readahead window 的第一个 page 就会被标记为 PG_readahead
