## Address Space - Routine

### add page

```c
int add_to_page_cache_lru(struct page *page, struct address_space *mapping,
				pgoff_t offset, gfp_t gfp_mask)
```

add_to_page_cache_lru() 将 page cache 添加到 address space 的 @offset 位置处，同时将该 page cache 添加到 LRU_INACTIVE_FILE lru list 中

```sh
# iomap based buffered IO
f_op->write_iter(kiocb, iov_iter)
    iomap_file_buffered_write()
        iomap_apply(..., IOMAP_WRITE, ..., iomap_write_actor)
            iomap_write_actor
                iomap_write_begin
                    page = grab_cache_page_write_begin
                         pagecache_get_page // find page cache
                            # create new page cache if not exist
                            page = __page_cache_alloc
                            add_to_page_cache_lru(page, ...) // add to address space
```


```sh
# fiemap based buffered IO
f_op->write_iter(kiocb, iov_iter)
    __generic_file_write_iter
        generic_perform_write
            a_ops->write_begin(), e.g., ext4_write_begin()
                page = grab_cache_page_write_begin()
                    pagecache_get_page // find page cache
                        # create new page cache if not exist
                        page = __page_cache_alloc
                        add_to_page_cache_lru(page, ...) // add to address space
                
                __block_write_begin
                    __block_write_begin_int
                        head = create_page_buffers(page, ...)
                            head = alloc_page_buffers // allocate all buffer heads of this page
                        
                        (for each buffer head) ll_rw_block(..., bh)                            
```


### cleanup

#### invalidate_mapping_pages

```c
unsigned long invalidate_mapping_pages(struct address_space *mapping,
		pgoff_t start, pgoff_t end)
```

invalidate_mapping_pages() 移除 address space 中 [start, end) file offset 区间内对应的 page cache，但是以下 page 不会被移除

- dirty page
- locked page
- 正在执行 writeback 的 page
- 通过 file memory mapping 被映射的 page

也就是说，invalidate_mapping_pages() 只会移除 clean, unused pages；对于 DAX mapping，invalidate_mapping_pages() 也不会做任何事

```sh
# page cache based
invalidate_mapping_pages
    (iterate pages) invalidate_inode_page(page)
        invalidate_complete_page(mapping, page)
            # there's block buffer list for FIEMAP,
            # or 'struct iomap_page' for IOMAP
            if page_has_private(page):
                try_to_release_page
                    a_ops->releasepage()
                        try_to_free_buffers(page)
                            drop_buffers(page)
                            # if all buffer heads are not busy, i.e., refcount of buffer head is 0
                            (for each buffer head) free_buffer_head // free buffer head
            
            # if releasepage() succeed, i.e., all buffer heads are not busy and thus freed
            remove_mapping(mapping, page)
                __delete_from_page_cache(page, ...) // delete from address space
                a_ops->freepage(), usually NULL
    
    pagevec_release // free page cache
```


例如 "echo 1 > /proc/sys/vm/drop_caches" 时就会调用 invalidate_mapping_pages()，其中会扫描所有文件系统中所有文件的 page cache，释放其中的 clean page

```sh
iterate_supers
    drop_pagecache_sb
        (iterate inodes) invalidate_mapping_pages    
```


#### invalidate_inode_pages2_range

```c
int invalidate_inode_pages2_range(struct address_space *mapping,
				  pgoff_t start, pgoff_t end)
```

与 invalidate_mapping_pages() 类似，但是 invalidate_inode_pages2_range() 会移除 address space 中的所有 page cache

> page cache based

```sh
# page cache based
invalidate_inode_pages2_range
    # for page under writeback
    wait_on_page_writeback(page) // wait until writeback completed
    
    # for file memory mapped page
    unmap_mapping_pages // unmap
    
    invalidate_complete_page2(mapping, page)
        # there's block buffer list for FIEMAP,
        # or 'struct iomap_page' for IOMAP
        if page_has_private(page):
            try_to_release_page
                a_ops->releasepage()
                    try_to_free_buffers(page)
                        drop_buffers(page)
                        # if all buffer heads are not busy, i.e., refcount of buffer head is 0
                        (for each buffer head) free_buffer_head // free buffer head
            
            # if releasepage() succeed, i.e., all buffer heads are not busy and thus freed
            
            __delete_from_page_cache(page, ...) // delete from address space
            a_ops->freepage(), usually NULL
    
    pagevec_release // free page cache
```

- 对于 locked page，会一直等待 lock 被释放，再释放 page
- 对于正在执行 writeback 的 page，会一直等待直到回写完成，再释放 page
- 对于 file memory mapped page，会解除映射之后再释放 page

对于 dirty page 或者 releasepage() 调用失败，例如该 page cache 对应的 buffer head 存在引用而无法被释放的情况下，invalidate_inode_pages2_range() 最终会返回 -EBUSY


> fs DAX

```sh
# fs DAX
invalidate_inode_pages2_range
    (iterate pages) invalidate_exceptional_entry2(mapping, index, page)
        # for DAX mapped page
        dax_invalidate_mapping_entry_sync(mapping, index)
            # if page is not dirty, delete from address space
            radix_tree_delete
    
    unmap_mapping_pages
        # for file memory mapped page
        unmap_mapping_range_tree // unmap
    
```

这里同样需要注意的是，对于 dirty page，invalidate_inode_pages2_range() 最终会返回 -EBUSY


#### truncate_pagecache

```c
void truncate_pagecache(struct inode *inode, loff_t newsize)
```

truncate_pagecache() 在将文件缩小时，会将文件 address space 中被 truncate 部分对应的 page cache 移除掉


```sh
# page cache based
truncate_pagecache(inode, newsize)
    truncate_inode_pages(inode, newsize)
        truncate_inode_pages_range
            
            # Pass 1: skip locked page and page under writeback
            (iterate pages) truncate_cleanup_page(mapping, page)
                # for file memory mapped page
                unmap_mapping_pages // unmap
                
                # there's block buffer list for FIEMAP,
                # or 'struct iomap_page' for IOMAP
                if page_has_private(page):
                    do_invalidatepage(page, ...)
                        a_ops->invalidatepage, e.g., block_invalidatepage(page, ...)
                            (for each block buffer) discard_buffer
                                clear_buffer_dirty(bh) // clear BH_Dirty in bh->b_state
                            
                            try_to_release_page
                                try_to_free_buffers(page)
                                    drop_buffers(page)
                                    # if all buffer heads are not busy, i.e., refcount of buffer head is 0, and block buffers are clean (previously BH_Dirty cleared)
                                    (for each buffer head) free_buffer_head // free buffer head

            delete_from_page_cache_batch    
                page_cache_tree_delete_batch // delete from address space
                page_cache_free_page
                    a_ops->freepage(), usually NULL
    
            pagevec_release // free page cache
            
            
            # Pass 2: truncate locked page and page under writeback
            for (;;) {
                # for locked page
                lock_page(page) // wait until page unlocked by others
                
                # for page under writeback
                wait_on_page_writeback(page) // wait until writeback completed
                
                truncate_inode_page // delete from address space
                pagevec_release // free page cache
            }
```

- 对于 locked page，会一直等待 lock 被释放，再释放 page
- 对于正在执行 writeback 的 page，会一直等待直到回写完成，再释放 page
- 对于 file memory mapped page，会解除映射之后再释放 page

对于 dirty page，因为这部分是被 truncate 的，因而即便是 dirty page 也会被释放掉；另外即使 releasepage() 调用失败，例如该 page cache 对应的 buffer head 存在引用而无法被释放的情况下，这部分 page 也会被释放掉

> fs DAX

```sh
# fs DAX
truncate_pagecache(inode, newsize)
    truncate_inode_pages(inode, newsize)
        truncate_inode_pages_range
            (iterate pages) truncate_exceptional_pvec_entries
                dax_delete_mapping_entry(mapping, index)
                    __dax_invalidate_mapping_entry
                        radix_tree_delete // delete from address space    
```

需要注意的是，此时 fs DAX 模式下 truncate_pagecache() 并不会和 invalidate_inode_pages2_range() 那样释放 file memory mapping 映射


### find page

#### find_get_page

```c
struct page *find_get_page(struct address_space *mapping, pgoff_t offset)
```

find_get_page() 在 address space 中查找特定 @offset 文件偏移对应的 page cache，返回该 page cache 对应的 page 描述符

函数实际在 address space 维护的 radix tree 中寻找对应的 page 描述符，当 radix tree 中存在该 page 描述符时，函数则增加该 page 描述符的引用计数，并返回该 page 描述符，否则函数返回 NULL


#### find_get_page_flags

```c
struct page *find_get_page_flags(struct address_space *mapping,
					pgoff_t offset, int fgp_flags)
```

find_get_page_flags() 类似地在特定的 address space 中查找特定 @offset 文件偏移对应的 page cache，返回该 page cache 对应的 page 描述符

与 find_get_page() 的差别在于，find_get_page_flags() 可以使用 @fgp_flags 参数，控制查找过程中的行为，@fgp_flags 参数的值可以为

- FGP_ACCESSED，调用 mark_page_accessed() 将找到的 page cache 对应的 page frame 标记为 accessed
- FGP_LOCK，调用 lock_page() 将找到的 page cache 对应的 page frame 标记为 locked
- FGP_CREAT，即当没有找到对应的 page cache 时
    - 调用 __page_cache_alloc() 从 zoned page frame allocator 分配一个新的 page frame
    - 同时调用 add_to_page_cache_lru() 将该新创建的 page frame 添加到 address space 的 index offset 位置处


#### find_lock_page

```c
struct page *find_lock_page(struct address_space *mapping, pgoff_t offset)
```

find_lock_page() 在特定的 address space 中查找特定 @offset 文件偏移对应的 page cache，同时会调用 lock_page() 将找到的 page cache 对应的 page frame 标记为 locked，以获得该 page frame 的 exclusive access

相当于 @fgp_flags 参数为 FGP_LOCK 的 find_get_page_flags()。当该 page 描述符 的 flags 标识位的 PG_locked bit 之前已经被设置，即该 page frame 当前已经被其他进程独占访问时，lock_page() 中需要调用 __lock_page()，其中会将当前进程设置为 TASK_UNINTERRUPTIBLE state，将该 page 描述符放入一个 wait queue，并调用该 page 描述符所属的 address space 的 sync_page() 回调函数，最后调用 io_schedule() 使当前进程进入阻塞状态

之后当该 page 描述符的 flags 标识位的 PG_locked bit 被清除，即其他进程释放对该 page 的独占访问时，内核会调用 unlock_page() 唤醒该阻塞进程


#### find_or_create_page

```c
struct page *find_or_create_page(struct address_space *mapping,
		pgoff_t index, gfp_t gfp_mask)
```

find_or_create_page() 在特定的 address space 中查找特定 @offset 文件偏移对应的 page cache，当 address space 中不存在对应的 page cache 时，分配一个新的 page frame，并添加到 address space 的 @index offset 位置处

相当于 @fgp_flags 参数为 FGP_LOCK|FGP_ACCESSED|FGP_CREAT 的 find_get_page_flags()


#### find_get_pages

```c
unsigned find_get_pages(struct address_space *mapping, pgoff_t start,
			    unsigned int nr_pages, struct page **pages)
```

find_get_pages() 在特定的 address space 中寻找特定 @offset 文件偏移起始的最多 @nr_pages 个 page cache

函数在传入的 @pages[] 数组中保存找到的 page cache，并返回找到的 page cache 的数量

@pages[] 数组中保存的 page cache 对应的 offset 递增，但不必连续，即 @pages[] 数组中保存最多 @nr_pages 个 offset 递增但不必连续的 page cache


#### find_get_pages_contig

```c
unsigned find_get_pages_contig(struct address_space *mapping, pgoff_t index,
			       unsigned int nr_pages, struct page **pages)
```

find_get_pages_contig() 与 find_get_pages() 相类似，只是需要寻找 @nr_pages 个 offset 递增且连续的 page cache



### remove page

```c
void delete_from_page_cache(struct page *page)
```

delete_from_page_cache() 将特定 page cache 从对应的 address space 中移除，同时调用该 address space 的 freepage() 回调函数


### read page

以上创建 page cache 的过程都只是分配 page frame 并添加到 address space 的对应位置，这些新分配的 page cache 实际上并没有读取磁盘上对应位置处的数据

```c
struct page *read_cache_page(struct address_space *mapping,
				pgoff_t index,
				int (*filler)(void *, struct page *),
				void *data)
```

read_cache_page() 将文件从磁盘读取到对应的 page cache 中，从而确保 address space 中 @index offset 位置处的 page cache 与磁盘中对应的 file 的对应 offset 处的数据保持同步

- 函数首先在 address space 中寻找 index offset 位置对应的 page cache，若 address space 中不存在该 page cache，则创建一个新的 page cache，同时将其添加到该 address space 中
- 之后调用传入的 filter() 回调函数，同时传入的 data 参数作为 filter() 的第一个参数，filter()回调函数读取磁盘中对应的 file 的对应位置处的数据，并将读取的数据保存到该 page 中，该 filter() 回调函数通常也用于实现 address space 的 readpage() 回调函数
