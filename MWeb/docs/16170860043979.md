title:'Writeback - 4 Dirty Throttle'
## Writeback - 4 Dirty Throttle


系统中 dirty page 的水平不能太高，因而内核中有好几个入口会发起 writeback 操作，其中一个入口是进程执行 page cache write routine 中，需要检查当前系统中所有 dirty page 的数量是否超过阈值，如果超过阈值，那么当前进程上下文就会停止当前的写操作，转而发起 writeback 操作，这一过程称为 dirty throttle


### Classic Dirty Throttle

在 v3.1 及其之前版本，采用的算法非常简单，即系统中 dirty page 的水平超过某个阈值时，就会发生 dirty throttle

```
                             |
              free run area  |  throttle area
-----------------------------+---------------------------->
                       thresh^                  dirty pages
```

这个阈值由以下两个参数决定
`thresh = (dirty_background_thresh + dirty_thresh) / 2)`

```
          (background writeback)
  free run   |   free run    | soft throttle | hard throttle
-------------+---------------+---------------+------------>
             ^               ^               ^          dirty pages
dirty_background_thresh     thresh          dirty_thresh
```

> dirty_background_thresh 由 `/proc/sys/vm/dirty_background_[bytes|ratio]` 控制，默认为整体内存的 10%
> dirty_thresh 由 `/proc/sys/vm/dirty_[bytes|ratio]` 控制，默认为整体内存的 20%


这一算法的设计原理是

1. free run area

如果当前系统中 dirty page 的水平超过了 dirty_background_thresh，但是还没有超过 thresh，那么考虑到系统会时不时地发起 background writeback 操作，因而此时可以先不发起 writeback 操作，寄希望于后台的 background writeback 操作可以追上生产 dirty page 的速度；这样可以减小 small-write dirty throttle 毛刺

2. soft throttle area

如果当前系统中 dirty page 的水平超过了 thresh，但是还没有超过 dirty_thresh，那么此时会检查当前写操作对应的 blkdev 设备的 dirty page 的水平是否超过了 dirty_thresh 中该设备对应的配额，超过的时候就会发生 dirty throttle

特定 blkdev 设备的 dirty_thresh 阈值的计算方法为

- writeback 框架维护一个全局的 @writeout_completions 计数，描述截止当前系统中所有 gendisk 完成回写的 dirty page 的数量
- 同时每个 gendisk 的 bdi 中维护一个本地的 @completions 计数，描述截止当前该 gendisk 完成回写的 dirty page 的数量
- 因而将 gendisk 的 @completions 计数除以全局的 @writeout_completions 计数，再乘以全局的 dirty_thresh，即得到该 gendisk 对应的 dirty_thresh 阈值，即经常执行回写操作同时回写速度快的 gendisk 设备具有更高的 dirty_thresh 阈值


3. hard throttle area

如果系统中 dirty page 的水平超过了 dirty_thresh 阈值，那么就会发生 dirty throttle


### IO-less Dirty Throttle

上述介绍的 Classic Dirty Throttle 算法，所有执行 page cache write 的进程都有可能进入 dirty throttle 流程，即多个进程上下文都会发起回写操作，这种算法存在以下缺陷

- 多个进程上下文发起回写操作，会加剧相关的锁竞争
- 多个进程上下文发起回写操作，每个进程都可能对一个 disk 上的一个文件执行回写操作，这样一个磁盘就会同时写多个文件，在 HDD 时代磁头就会剧烈抖动，导致磁盘性能下降

因而 吴峰光 (Fengguang Wu) 在 v3.2 版本合入的 IO-less Dirty Throttle 特性中，当发生 dirty throttle 时，当前进程上下文会发起 background writeback，之后进入 TASK_KILLABLE 状态睡眠一段时间，这样当前进程上下文不再直接执行回写操作，而是统一由 worker thread 执行回写，从而缩小了回写的并发度，缓解了以上问题


此外考虑到 dirty throttle 并不是用户期望的，因为 dirty throttle 会带来进程的停顿，因而 dirty throttle 更多是一种托底的方案，我们需要尽可能地减小 dirty throttle 发生的几率

虽然发生 dirty throttle 的时候，当前进程上下文会发起 background writeback 操作，然而进程生产 dirty page 的速度仍然可能快于 background writeback 回写的速度，因而 IO-less Dirty Throttle 特性的思想就是，在发生 dirty throttle 的时候，在发起 background writeback 之后，当前进程上下文需要暂停写入（即进入 TASK_KILLABLE 状态睡眠）一段时间，从而抑制 dirty page 的产生，而这也正是 "IO-less" 名称的由来


和 Classic Dirty Throttle 算法中类似地，在 free_run 阈值之前并不会发生 dirty throttle，只有在 free_run 阈值之后才会发生 dirty throttle，也就是发起 background writeback 的同时，让当前进程睡眠一段时间，从而抑制 dirty page 的产生

`free_run = (dirty_background_thresh + dirty_thresh) / 2)`

```
          (background writeback)
  free run   |   free run    | soft throttle | hard throttle       
-------------+---------------+---------------+------------>
             ^               ^               ^          dirty pages
dirty_background_thresh     free_run         dirty_thresh
```

因而 "IO-less" 算法后续的主要工作，就是在触发 dirty throttle 的时候，计算进程需要睡眠的时间



Dirty Throttle 的入口为 balance_dirty_pages()，在 write routine 中都会调用该函数检查当前系统中 dirty page 的水位，以决定是否对当前执行 write 操作的进程进行 dirty throttle

```
generic_perform_write
    balance_dirty_pages_ratelimited
        balance_dirty_pages
```

```c
void balance_dirty_pages(struct bdi_writeback *wb, unsigned long pages_dirtied)
```

这里 @wb 在没有开启 cgroup writeback 的时候，就是当前被写入的设备对应的 bdi->wb；在开启 cgroup writeback 的时候，就是当前进程所在的 cgroup 对应的 wb

@pages_dirtied 就是当前进程写入并置脏的 page 的数量


#### free_run

balance_dirty_pages() 中使用 struct dirty_throttle_control 来保存一些计算出来的参数，@mdtc 只有在开启 cgroup writeback 的时候才会使用到；在未开启 cgroup writeback 的时候，只会使用到 gdtc，此时 mdtc 为 NULL

```c
balance_dirty_pages
    struct dirty_throttle_control *gdtc = ...
    struct dirty_throttle_control *mdtc = ...
```


首先需要计算 free_run，这是一个全局的参数

`free_run = (dirty_background_thresh + dirty_thresh) / 2)`

free_run 由 dirty_background_thresh、dirty_thresh 这两个参数计算得来，这两个参数由 `/proc/sys/vm/dirty_background_[bytes|ratio]` 和 `/proc/sys/vm/dirty_[bytes|ratio]` 控制，计算的结果分别保存在 @thresh、@bg_thresh 字段

```sh
balance_dirty_pages
    gdtc->avail = # calculate number of globally dirtyable pages (NR_FREE_PAGES + NR_INACTIVE_FILE + NR_ACTIVE_FILE)
    gdtc->dirty = # calculate number of globally dirty pages (NR_FILE_DIRTY + NR_WRITEBACK)
    domain_dirty_limits(gdtc)
        gdtc->thresh = gdtc->avail * dirty_ratio
        gdtc->bg_thresh = gdtc->avail * dirty_background_ratio
```

```c
struct dirty_throttle_control {
	unsigned long		avail;		/* dirtyable */
	unsigned long		dirty;		/* file_dirty + write + nfs */
	unsigned long		thresh;		/* dirty threshold */
	unsigned long		bg_thresh;	/* dirty background threshold */
	...
};
```

@avail 字段保存系统中所有可以用于 page cache 的内存的数量
@dirty 字段保存系统中所有 dirty page 的数量

上述 struct dirty_throttle_control 中保存的所有参数均以 PAGE_SIZE 为单位


在计算出系统全局的 free_run 参数之后，就可以判断当前系统中全局 dirty page 的水位是否超过了 free_run，如果全局 dirty page 的水位在 free_run 以下，就不需要做 dirty throttle

```sh
balance_dirty_pages
    dirty = gdtc->dirty
    thresh = gdtc->thresh
    bg_thresh = gdtc->bg_thresh
    free_run = (thresh + bg_thresh) / 2
    
    if dirty <= free_run:
        return # skip dirty throttle
```


#### setpoint

而如果全局 dirty page 的水位超过了 free_run，当前进程就会执行 dirty throttle 操作，实际上也就是睡眠一段时间，从而抑制 dirty page 的产生；这里 IO-less Dirty Throttle 算法的主要工作，就是计算进程需要睡眠的时间，即 pause time

而为了计算 pause time，IO-less Dirty Throttle 算法引入的一个重要概念是“平衡点”即 setpoint，这是考虑到系统中 dirty page 的水平不能太高，也不能太低，而是要维持在一个合理的水位即 setpoint

dirty page 的水平不能太高，如果太高那么文件写入的过程中就可能找不到 free page cache 可用，当然也不能太低，如果太低那么内存的使用率就会很低，无法充分发挥内存的能力，从而导致写入的带宽无法提升


因而 IO-less Dirty Throttle 算法会控制用户进程生产 dirty page 的速度与 background writeback 回写的速度，从而让系统中 dirty page 的水平尽量维持在 setpoint 水位附近

当系统中 dirty page 的水平在 setpoint 以下时，在触发 dirty throttle 的时候就会让 pause time 短一些，从而让 dirty page 的水位上升；系统中 dirty page 的水平在 setpoint 之上时，就让 pause time 长一些，从而让 dirty page 的水位下降


IO-less Dirty Throttle 算法中的 setpoint 由以下公式计算

`setpoint = (free_run + dirty_thresh) / 2)`

```
                                  setpoint
-------------+---------------+-------+-------+------------>
             ^               ^               ^          dirty pages
dirty_background_thresh     free_run         dirty_thresh
```


#### balanced_dirty_ratelimit

之前介绍过 IO-less Dirty Throttle 算法需要控制触发 dirty throttle 时，进程睡眠的时间；如果能够获取得到进程生产 dirty page 的速度，就能根据 balance_dirty_pages() 传入的 @pages_dirtied 参数，也就是当前进程写入并置脏的 page 的数量，将两者相除就可以计算得到当前进程需要睡眠的时间

因而 IO-less Dirty Throttle 算法中会计算对于一个进程来说，进程以怎样的速度生产 dirty page，系统中 dirty page 的水平会保持不变，即保持在 setpoint 位置，我们将这个速度称为 balanced_dirty_ratelimit


以下描述 balanced_dirty_ratelimit 计算公式的推导过程

首先以下公式不言自明，dirty_rate 表示生产 dirty page 的速度，write_bw 表示 dirty page 回写的速度，长期来看两者一定是相等的

```
dirty_rate == write_bw                                      (1)
```


task_ratelimit 表示每个进程生产 dirty page 的速度，假设当前系统中有 N 个进程在生产 dirty page，那么为了确保系统中 dirty page 的水平保持不变，task_ratelimit 有以下计算公式

```
task_ratelimit = balanced_dirty_ratelimit == write_bw / N   (2)
```


根据 (2) 可以得到以下变式，其中 dirty_rate 表示系统生产 dirty page 的速度

```
                            dirty_rate     write_bw
balanced_dirty_ratelimit =  ----------- * ----------        (3)
                                 N         dirty_rate
```


同时以下等式也是不言自明的

```
dirty_rate == N * task_ratelimit                            (4)         
```


将 (4) 代入 (3)，就可以得到

```
                                              write_bw
balanced_dirty_ratelimit =  task_ratelimit * ----------     (5)
                                              dirty_rate
```

将 (2) 代入 (5)，就可以得到

```
                              write_bw
balanced_dirty_ratelimit *=  ----------                     (6)
                              dirty_rate
```


也就是说虽然我们不知道进程中生产 dirty page 的进程的数量 N，但是最终我们可以用一种启发式的算法即等式 (6)，计算得到 balanced_dirty_ratelimit，即为了确保系统中 dirty page 的水平保持不变，每个进程生产 dirty page 的速度


上述等式 (6) 中有三个输入

- 上一个采样周期的 balanced_dirty_ratelimit，算法每隔 BANDWIDTH_INTERVAL 即 200ms 更新一次该数据，初始值是 task_ratelimit_0
- write_bw 即 dirty page 回写的速度，dirty_rate 即生产 dirty page 的速度，这两者都可以通过 dirty page 产生、回写过程中维护相应的计数器来进行计算


> write_bw (write bandwidth)

```c
struct bdi_writeback {
	unsigned long avg_write_bandwidth; /* further smoothed write bw, > 0 */
	...
}
```

首先介绍 write_bw 的计算方法

之前我们讨论 dirty_rate == write_bw 时，系统中 dirty page 的水平可以保持不变，此时这两个参数包括系统中所有 disk 设备的 dirty page；但是 disk 的速度存在差异，如果只是维护整个系统的 dirty_rate/rite_bw 参数，就有可能因为速度快的 disk 设备占用了太多的带宽，而导致速度慢的 disk 设备反而被 throttle 了

因而为了不同 disk 设备之间的公平性，dirty_rate/write_bw 参数都是 per-wb 范围的，即每个 disk 设备都会维护一组 dirty_rate/write_bw 参数，例如 write_bw 就维护在 @wb->avg_write_bandwidth 中

```sh
balance_dirty_pages
    __wb_update_bandwidth
        wb_update_write_bandwidth
           elapsed = (jiffies - wb->bw_time_stamp) / HZ;
           written = percpu_counter_read(&wb->stat[WB_WRITTEN]) - wb->written_stamp;
           wb->avg_write_bandwidth = written / elapsed;
```

首先通过 (wb->stat[WB_WRITTEN] - wb->written_stamp) 获取当前这个采样周期中回写的 dirty page 的数量 (@wb->written_stamp 表示截止上一个采样周期 wb->stat[WB_WRITTEN] 计数的值)

之后通过 (jiffies - wb->bw_time_stamp) 计算当前这个采样周期已经过去的时间

以上两者相除，就得到截止当前这个采样周期 write_bw 的值


> dirty_rate

类似地，dirty_rate 的计算过程为

```sh
balance_dirty_pages
    __wb_update_bandwidth
        wb_update_dirty_ratelimit
            elapsed = (jiffies - wb->bw_time_stamp) / HZ;
            dirtied = percpu_counter_read(&wb->stat[WB_DIRTIED]) - wb->dirtied_stamp;
            dirty_rate = dirtied / elapsed;
```


> balanced_dirty_ratelimit

```c
struct bdi_writeback {
	unsigned long balanced_dirty_ratelimit;
	...
}
```

在已知 write_bw 和 dirty_rate 的情况下，根据以下计算公式

```
                              write_bw
balanced_dirty_ratelimit *=  ----------                     (6)
                              dirty_rate
```

就可以计算得到 balanced_dirty_ratelimit

```sh
balance_dirty_pages
    __wb_update_bandwidth
        wb_update_dirty_ratelimit
            write_bw = ...
            dirty_rate = ...
            wb->balanced_dirty_ratelimit *= write_bw / dirty_rate;
```


#### dirty_ratelimit

上述介绍的 balanced_dirty_ratelimit 描述了对于一个进程来说，进程以怎样的速度生产 dirty page，系统中 dirty page 的水平会保持不变，即保持在 setpoint 位置

balanced_dirty_ratelimit 的值由 write_bw 和 dirty_rate 参数决定，每隔 BANDWIDTH_INTERVAL 即 200ms 更新一次，因而该参数的值会发生跳变；而为了让 IO-less Dirty Throttle 算法的运行过程更加平滑，额外维护一个参数叫 dirty_ratelimit

```c
struct bdi_writeback {
	/*
	 * @dirty_ratelimit tracks the estimated @balanced_dirty_ratelimit
	 * in small steps and is much more smooth/stable than the latter.
	 */
	unsigned long dirty_ratelimit;
	...
}
```

dirty_ratelimit 会在 balanced_dirty_ratelimit 的基础上，变化地更加平滑

```sh
balance_dirty_pages
    __wb_update_bandwidth
        wb_update_dirty_ratelimit
            wb->balanced_dirty_ratelimit *= write_bw / dirty_rate;
            wb->dirty_ratelimit = ... # calculate based on balanced_dirty_ratelimit
```


#### pos_ratio

以上计算得到的 balanced_dirty_ratelimit 只能确保系统中 dirty page 的水平保持不变

如果当前系统中 dirty page 的水平已经超过了 setpoint，那么当前可用的 dirty_ratelimit 配额需要小于 balanced_dirty_ratelimit，使得 dirty page 回写的速度大于产生的速度，从而让系统中 dirty page 的水平降至 setpoint 水位

类似地，如果当前系统中 dirty page 的水平在 setpoint 以下，那么当前可用的 dirty_ratelimit 配额可以大于 balanced_dirty_ratelimit，使得 dirty page 回写的速度小于产生的速度，从而让系统中 dirty page 的水平回升至 setpoint 水位

此时需要使用一个参数对上述计算的 balance_dirty_pages 进行修正，得到最后可用的 task_ratelimit，这个参数就称为 pos_ratio

```sh
balance_dirty_pages
    wb_position_ratio // calculate pos_ratio
    task_ratelimit = wb->dirty_ratelimit * pos_ratio;
```


正如之前描述的，pos_ratio 应该是一个随着当前系统中 dirty page 的水平而动态变化的函数

- 当前系统中 dirty page 的水平在 setpoint 时，pos_ratio 应该为 1，此时系统中 dirty page 产生和回写的速度相当，从而使得系统中 dirty page 的水平保持在 setpoint 水位
- 当前系统中 dirty page 的水平大于 setpoint 时，pos_ratio 应该小于 1，使得 dirty page 回写的速度大于产生的速度，从而降低系统中 dirty page 的水平；同时 dirty page 水平越大，斜率应该越大，即 pos_ratio 下降地越快，从而达到快速抑制 dirty page 水平的目的
- 类似地，当前系统中 dirty page 的水平小于 setpoint 时，pos_ratio 应该大于 1，使得 dirty page 回写的速度小于产生的速度，从而抬升系统中 dirty page 的水平；同时 dirty page 水平越小，斜率应该越大，即 pos_ratio 上升地越快，从而达到快速抬升 dirty page 水平的目的


因而我们就得到了以下 pos_ratio 曲线

```
    ^ pos_ratio
    |
    |            |<===== global dirty control scope ======>|
2.0 .............*
    |            .*
    |            . *
    |            .   *
    |            .     *
    |            .        *
    |            .            *
1.0 ................................*
    |            .                  .     *
    |            .                  .          *
    |            .                  .              *
    |            .                  .                 *
    |            .                  .                    *
  0 +------------.------------------.----------------------*------------->
          freerun^          setpoint^                 limit^   dirty pages
```

实际上，pos_ratio 曲线是一个三次多项式函数

```
                   setpoint - dirty 3
f(dirty) := 1.0 + (----------------)
                   limit - setpoint
```

```sh
balance_dirty_pages
    wb_position_ratio(gdtc)
        pos_ratio = pos_ratio_polynom() # calculate pos_ratio
```


> wb's pos_ratio

上述计算出来的 pos_ratio 是一个全局的 pos_ratio (根据全局的 setpoint 即全局 dirty_background_thresh/dirty_thresh 计算出来)

之后需要根据当前 bdi 完成的回写量占整个系统回写量的百分比，在全局 pos_ratio 的基础上，计算得到 bdi 设备对应的 pos_ratio；因为后面 pos_ratio 会影响 dirty throttle 过程中进程睡眠的时间，即 pause time，从而使得当前 bdi 对应的 dirty_thresh 配额还有富余的时候，pause time 可以短一些

> /*
>  * We have computed basic pos_ratio above based on global situation. If
>  * the wb is over/under its share of dirty pages, we want to scale
>  * pos_ratio further down/up. That is done by the following mechanism.
>  */


```
f(wb_dirty) := 1.0 + k * (wb_dirty - wb_setpoint)

where "k = - 1 / (8 * write_bw)"
```

也就是说

```
                    wb_dirty - wb_setpoint
f(wb_dirty) := 1.0 - (----------------)
                        8 * write_bw
```

这里的 wb_setpoint = setpoint * gdtc->wb_thresh / gdtc->thresh


wb_thresh 和 wb_bg_thresh 由以下方式计算

```sh
balance_dirty_pages
    wb_dirty_limits(gdtc)
        gdtc->wb_thresh = ... # calc this bdi's share of gdtc->thresh
        gdtc->wb_thresh can't exceed gdtc->thresh * bdi->max_ratio
        
        gdtc->wb_bg_thresh = ... # calc this bdi's share of gdtc->wb_bg_thresh
        gdtc->wb_dirty = ... # calc number of this bdi's dirty pages (WB_RECLAIMABLE + WB_WRITEBACK)
```

这里会根据 bdi 完成的回写量占整个系统回写量的百分比，计算该 bdi 在全局 dirty_thresh 中的配额，作为 wb_thresh；但是这个百分比不能超过该 bdi->max_ratio，用户可以通过 `/sys/class/bdi/<bdi>/max_ratio` 控制 bdi 的 max_ratio 参数

```c
struct dirty_throttle_control {
	unsigned long		wb_dirty;	/* per-wb counterparts */
	unsigned long		wb_thresh;
	unsigned long		wb_bg_thresh;
	...
};
```

@wb_thresh 字段描述该 bdi 设备在全局 dirty_thresh 中的配额
@wb_bg_thresh 字段描述该 bdi 设备在全局 dirty_background_thresh 中的配额
@wb_dirty 字段描述该 bdi 设备中所有 dirty page 的数量

上述 struct dirty_throttle_control 中保存的所有参数均以 PAGE_SIZE 为单位


上述计算 bdi 设备对应的 pos_ratio 的过程中，需要计算当前 bdi 完成的回写量占整个系统回写量的百分比，这是通过 @completions 计数来计算的

- @global_wb_domain->completions 计数保存全局的 @completions 计数，每个 dirty page 成功完成回写的时候，都会增加该计数
- 每个 bdi 设备自己也维护了一个 completions 计数，即 即 @bdi->wb->completions 计数，保存 bdi 自己完成回写的 dirty page 的数量，每个 dirty page 成功完成回写的时候，也会增加该计数

```sh
end_page_writeback
    test_clear_page_writeback
        __wb_writeout_inc
            wb_domain_writeout_inc(&global_wb_domain, &wb->completions, ...)
```


#### task_ratelimit

task_ratelimit 表示每个进程经过 pos_ratio 调整后，可以生产的 dirty page 的速度，根据以下公式

```
task_ratelimit = wb->dirty_ratelimit * pos_ratio;
```

就可以在 balanced_dirty_ratelimit 的基础上，经过 pos_ratio 修正，得到task_ratelimit

task_ratelimit 具有以下曲线

```
  ^ task rate limit
  |
  |            *
  |             *
  |              *
  |[free run]      *      [smooth throttled]
  |                  *
  |                     *
  |                         *
  ..bdi->dirty_ratelimit..........*
  |                               .     *
  |                               .          *
  |                               .              *
  |                               .                 *
  |                               .                    *
  +-------------------------------.-----------------------*------------>
                          setpoint^                  limit^  dirty pages
```


最终经 pos_ratio 修正后得到的 task_ratelimit (即每个进程产生 dirty page 的速度) 有

```
task_ratelimit = (u64)dirty_ratelimit * pos_ratio >> RATELIMIT_CALC_SHIFT;
```

```sh
balance_dirty_pages
    wb_position_ratio(gdtc)

```


#### pause time

在得到 task_ratelimit 之后，根据 balance_dirty_pages() 传入的 @pages_dirtied 参数，也就是当前进程写入并置脏的 page 的数量，将其除以task_ratelimit，就可以计算得到当前进程需要睡眠的时间，即 pause time

此时当前进程上下文需要暂停的时间即为

```
pause = HZ * pages_dirtied / task_ratelimit;
```

pages_dirtied 为 balance_dirty_pages() 传入的 @pages_dirtied 参数，即当前一次写操作需要写入的 dirty page 数量


之后当前进程上下文就会进入 TASK_KILLABLE 状态睡眠一段时间 (@pause)，睡眠结束后就会继续写入 dirty page

```sh
balance_dirty_pages
    for (;;) {
        pause = HZ * pages_dirtied / task_ratelimit;
        __set_current_state(TASK_KILLABLE);
        io_schedule_timeout(pause);
        
        if (task_ratelimit)
            break;
        ...
    }
```




