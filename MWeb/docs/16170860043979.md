title:'Writeback - 4 Dirty Throttle'
## Writeback - 4 Dirty Throttle


系统中 dirty page 的水平不能太高，buffer write 路径中就会检查当前系统中所有 dirty page 的水平，如果 dirty page 的数量超过阈值，那么当前进程上下文就会停止当前的写操作，转而发起 writeback 操作，这一过程称为 dirty throttle


### Classic Dirty Throttle

在 v3.1 及其之前版本，采用的算法非常简单，即系统中 dirty page 的水平超过某个阈值时，就会发生 dirty throttle

```
                             |
              free run area  |  throttle area
-----------------------------+---------------------------->
                     free_run^                  dirty pages
```

这个阈值由以下两个参数决定
`free_run = (dirty_background_thresh + dirty_thresh) / 2)`

```
          (background writeback)
  free run   |   free run    | soft throttle | hard throttle
-------------+---------------+---------------+------------>
             ^               ^               ^          dirty pages
dirty_background_thresh   free_run      dirty_thresh
```

> dirty_background_thresh 由 `/proc/sys/vm/dirty_background_[bytes|ratio]` 控制，默认为整体内存的 10%
> dirty_thresh 由 `/proc/sys/vm/dirty_[bytes|ratio]` 控制，默认为整体内存的 20%


这一算法的设计原理是

1. free run

如果当前系统中 dirty page 的水平超过了 dirty_background_thresh，但是还没有超过 thresh，那么考虑到系统会时不时地发起 background writeback 操作，因而此时可以先不发起 writeback 操作，寄希望于后台的 background writeback 操作可以追上生产 dirty page 的速度；这样可以减小 small-write dirty throttle 毛刺

2. soft throttle

如果当前系统中 dirty page 的水平超过了 thresh，但是还没有超过 dirty_thresh，那么此时会检查当前写操作对应的 blkdev 设备的 dirty page 的水平是否超过了 dirty_thresh 中该设备对应的配额，超过的时候就会发生 dirty throttle

特定 blkdev 设备的 dirty_thresh 阈值的计算方法为

- writeback 框架维护一个全局的 @writeout_completions 计数，描述截止当前系统中所有 gendisk 完成回写的 dirty page 的数量
- 同时每个 gendisk 的 bdi 中维护一个本地的 @completions 计数，描述截止当前该 gendisk 完成回写的 dirty page 的数量
- 因而将 gendisk 的 @completions 计数除以全局的 @writeout_completions 计数，再乘以全局的 dirty_thresh，即得到该 gendisk 对应的 dirty_thresh 阈值，即经常执行回写操作同时回写速度快的 gendisk 设备具有更高的 dirty_thresh 阈值


3. hard throttle

如果系统中 dirty page 的水平超过了 dirty_thresh 阈值，那么就会发生 dirty throttle


### IO-less Dirty Throttle

上述介绍的 Classic Dirty Throttle 算法，所有执行 buffer write 的进程都有可能进入 dirty throttle 流程，即多个进程上下文都会发起回写操作，这种算法存在以下缺陷

- 多个进程上下文发起回写操作，会加剧相关的锁竞争
- 多个进程上下文发起回写操作，每个进程都可能对一个 disk 上的一个文件执行回写操作，这样一个磁盘就会同时写多个文件，在 HDD 时代磁头就会剧烈抖动，导致磁盘性能下降

因而 吴峰光 (Fengguang Wu) 在 v3.2 版本合入的 IO-less Dirty Throttle 特性中，当发生 dirty throttle 时，当前进程上下文会发起 background writeback，之后进入 TASK_KILLABLE 状态睡眠一段时间，这样当前进程上下文不再直接执行回写操作，而是统一由 worker thread 执行回写，从而缩小了回写的并发度，缓解了以上问题


此外考虑到 dirty throttle 并不是用户期望的，因为 dirty throttle 会带来进程的停顿，因而 dirty throttle 更多是一种托底的方案，我们需要尽可能地减小 dirty throttle 发生的几率

虽然发生 dirty throttle 的时候，当前进程上下文会发起 background writeback 操作，然而进程生产 dirty page 的速度仍然可能快于 background writeback 回写的速度，因而 IO-less Dirty Throttle 特性的思想就是，在发生 dirty throttle 的时候，在发起 background writeback 之后，当前进程上下文需要暂停写入（即进入 TASK_KILLABLE 状态睡眠）一段时间，从而抑制 dirty page 的产生，而这也正是 "IO-less" 名称的由来


和 Classic Dirty Throttle 算法中类似地，在 free_run 阈值之前并不会发生 dirty throttle，只有在 free_run 阈值之后才会发生 dirty throttle，也就是发起 background writeback 的同时，让当前进程睡眠一段时间，从而抑制 dirty page 的产生

`free_run = (dirty_background_thresh + dirty_thresh) / 2)`

```
          (background writeback)
  free run   |   free run    |      dirty throttle       
-------------+---------------+---------------+------------>
             ^               ^               ^          dirty pages
dirty_background_thresh     free_run         dirty_thresh
```

因而 "IO-less" 算法后续的主要工作，就是在触发 dirty throttle 的时候，计算进程需要睡眠的时间


Dirty Throttle 的入口为 balance_dirty_pages()，在 write routine 中都会调用该函数检查当前系统中 dirty page 的水位，以决定是否对当前执行 write 操作的进程进行 dirty throttle

```
generic_perform_write
    balance_dirty_pages_ratelimited
        balance_dirty_pages
```

```c
void balance_dirty_pages(struct bdi_writeback *wb, unsigned long pages_dirtied)
```

这里 @wb 在没有开启 cgroup writeback 的时候，就是当前被写入的设备对应的 bdi->wb；在开启 cgroup writeback 的时候，就是当前进程所在的 cgroup 对应的 wb

@pages_dirtied 就是当前进程写入并置脏的 page 的数量


#### free_run

balance_dirty_pages() 中使用 struct dirty_throttle_control 来保存一些计算出来的参数，@mdtc 只有在开启 cgroup writeback 的时候才会使用到；在未开启 cgroup writeback 的时候，只会使用到 gdtc，此时 mdtc 为 NULL

```c
balance_dirty_pages
    struct dirty_throttle_control *gdtc = ...
    struct dirty_throttle_control *mdtc = ...
```


首先需要计算 free_run，这是一个全局的参数

`free_run = (dirty_background_thresh + dirty_thresh) / 2)`

free_run 由 dirty_background_thresh、dirty_thresh 这两个参数计算得来，这两个参数由 `/proc/sys/vm/dirty_background_[bytes|ratio]` 和 `/proc/sys/vm/dirty_[bytes|ratio]` 控制，计算的结果分别保存在 @thresh、@bg_thresh 字段

dirty_thresh 参数也叫做 write-back cache，即系统全局允许的 dirty page (需要 writeback) 的上限值 (但不是 hardlimit)

```sh
balance_dirty_pages
    gdtc->avail = # calculate number of globally dirtyable pages (NR_FREE_PAGES + NR_INACTIVE_FILE + NR_ACTIVE_FILE)
    gdtc->dirty = # calculate number of globally dirty pages (NR_FILE_DIRTY + NR_WRITEBACK)
    domain_dirty_limits(gdtc)
        gdtc->thresh = gdtc->avail * dirty_ratio
        gdtc->bg_thresh = gdtc->avail * dirty_background_ratio
```

```c
struct dirty_throttle_control {
	unsigned long		avail;		/* dirtyable */
	unsigned long		dirty;		/* file_dirty + write + nfs */
	unsigned long		thresh;		/* dirty threshold */
	unsigned long		bg_thresh;	/* dirty background threshold */
	...
};
```

@avail 字段保存系统中所有可以用于 page cache 的内存的数量
@dirty 字段保存系统中所有 dirty page 的数量

上述 struct dirty_throttle_control 中保存的所有参数均以 PAGE_SIZE 为单位


在计算出系统全局的 free_run 参数之后，就可以判断当前系统中全局 dirty page 的水位是否超过了 free_run，如果全局 dirty page 的水位在 free_run 以下，就不需要做 dirty throttle

```sh
balance_dirty_pages
    dirty = gdtc->dirty
    thresh = gdtc->thresh
    bg_thresh = gdtc->bg_thresh
    free_run = (thresh + bg_thresh) / 2
    
    if dirty <= free_run:
        return # skip dirty throttle
```


#### setpoint

而如果全局 dirty page 的水位超过了 free_run，当前进程就会执行 dirty throttle 操作，实际上也就是睡眠一段时间，从而抑制 dirty page 的产生；这里 IO-less Dirty Throttle 算法的主要工作，就是计算进程需要睡眠的时间，即 pause time

而为了计算 pause time，IO-less Dirty Throttle 算法引入的一个重要概念是“平衡点”即 setpoint，这是考虑到系统中 dirty page 的水平不能太高，也不能太低，而是要维持在一个合理的水位即 setpoint

dirty page 的水平不能太高，如果太高那么文件写入的过程中就可能找不到 free page cache 可用，当然也不能太低，如果太低那么内存的使用率就会很低，无法充分发挥内存的能力，从而导致写入的带宽无法提升


因而 IO-less Dirty Throttle 算法会控制用户进程生产 dirty page 的速度与 background writeback 回写的速度，从而让系统中 dirty page 的水平尽量维持在 setpoint 水位附近

当系统中 dirty page 的水平在 setpoint 以下时，在触发 dirty throttle 的时候就会让 pause time 短一些，从而让 dirty page 的水位上升；系统中 dirty page 的水平在 setpoint 之上时，就让 pause time 长一些，从而让 dirty page 的水位下降


IO-less Dirty Throttle 算法中的 setpoint 由以下公式计算

`setpoint = (free_run + dirty_thresh) / 2)`

```
          (background writeback)
  free run   |   free run    |      dirty throttle
-------------+---------------+-------+-------+------------>
             ^               ^    setpoint   ^          dirty pages
dirty_background_thresh     free_run         dirty_thresh
```

setpoint 主要影响后续介绍的 pos_ratio，setpoint 处 pos_ratio 的值为 1


#### balanced_dirty_ratelimit

之前介绍过 IO-less Dirty Throttle 算法需要控制触发 dirty throttle 时，进程睡眠的时间；如果能够获取得到进程生产 dirty page 的速度，就能根据 balance_dirty_pages() 传入的 @pages_dirtied 参数，也就是当前进程写入并置脏的 page 的数量，将两者相除就可以计算得到当前进程需要睡眠的时间

因而 IO-less Dirty Throttle 算法中会计算对于一个进程来说，进程以怎样的速度生产 dirty page，系统中 dirty page 的水平会保持不变，即保持在 setpoint 位置，我们将这个速度称为 balanced_dirty_ratelimit


以下描述 balanced_dirty_ratelimit 计算公式的推导过程

首先以下公式不言自明，`dirty_rate` 表示整个系统生产 dirty page 的速度，`write_bw` 表示整个系统 dirty page 回写的速度，长期来看两者一定是相等的

```
dirty_rate == write_bw                                      (1)
```


`balanced_dirty_ratelimit` 描述一个进程以怎样的速度生产 dirty page，可以使得系统中 dirty page 的水平保持不变。假设当前系统中有 N 个进程在生产 dirty page，那么为了确保系统中 dirty page 的水平保持不变，有以下计算公式

```
balanced_dirty_ratelimit == write_bw / N   (2)
```


根据 (2) 可以得到以下变式

```
                            dirty_rate     write_bw
balanced_dirty_ratelimit =  ----------- * ----------        (3)
                                 N         dirty_rate
```


同时以下等式也是不言自明的，其中 `task_ratelimit` 表示每个进程生产 dirty page 的速度

```
dirty_rate == N * task_ratelimit                            (4)         
```


将 (4) 代入 (3)，就可以得到

```
                                              write_bw
balanced_dirty_ratelimit =  task_ratelimit * ----------     (5)
                                              dirty_rate
```


同时考虑到在 setpoint 附近

```
task_ratelimit == balanced_dirty_ratelimit                  (6)
```


将 (6) 代入 (5)，就可以得到

```
                              write_bw
balanced_dirty_ratelimit *=  ----------                     (6)
                              dirty_rate
```


也就是说虽然我们不知道系统中生产 dirty page 的进程的数量 N，但是我们可以用一种启发式的算法即等式 (6)，最终计算得到 balanced_dirty_ratelimit，即为了确保系统中 dirty page 的水平保持不变，每个进程生产 dirty page 的速度


上述等式 (6) 中有三个输入

- 上一个采样周期的 `balanced_dirty_ratelimit`，算法每隔 BANDWIDTH_INTERVAL 即 200ms 更新一次该数据，初始值是 task_ratelimit_0
- `write_bw` 即整个系统中 dirty page 回写的速度，`dirty_rate` 即整个系统中生产 dirty page 的速度，这两者都可以通过 dirty page 产生、回写过程中维护相应的计数器来进行计算


##### write_bw (write bandwidth)

之前我们介绍到，`write_bw` 描述整个系统中 dirty page 回写的速度，即回写带宽，包括系统中所有 disk 设备的回写带宽；但是 disk 设备的速度存在差异，如果只是维护整个系统的 write_bw 参数，就有可能因为速度快的 disk 设备占用了太多的带宽，而导致速度慢的 disk 设备反而被 throttle 了

因而为了不同 disk 设备之间的公平性，write_bw 参数都是 per-wb 范围的，即每个 disk 设备都会维护自己的 write_bw 参数

```c
struct bdi_writeback {
	unsigned long avg_write_bandwidth; /* further smoothed write bw, > 0 */
	...
}
```

wb's write bandwidth estimation 由吴峰光在 commit e98be2d ("writeback: bdi write bandwidth estimation") 引入，最初用于描述设备在过去一段时间的写带宽，后面也用于描述 cgroup writeback 中对应 cgroup 的回写带宽


> stat[WB_WRITTEN]

wb->stat[WB_WRITTEN] 计数器描述该 wb 完成回写的 page 的数量

```c
struct bdi_writeback {
	struct percpu_counter stat[NR_WB_STAT_ITEMS];
	...
}
```

文件系统中每个 page 完成回写的时候都会增加该计数器

```
bio->bi_end_io(), e.g., ext4_end_bio
    ext4_finish_bio
        end_page_writeback
            test_clear_page_writeback
                __wb_writeout_inc
                    inc_wb_stat(wb, WB_WRITTEN)
```


> write bandwidth estimation

wb->write_bandwidth 字段描述该 wb 在过去一段时间内执行回写操作时，产生的 IO 平均带宽；wb->avg_write_bandwidth 则是对 wb->write_bandwidth 平滑处理、过滤掉毛刺过后的版本，也就是 dirty throttle 算法实际用到的 `write bandwidth`

```c
struct bdi_writeback {
	unsigned long bw_time_stamp;	/* last time write bw is updated */
	unsigned long written_stamp;	/* pages written at bw_time_stamp */
	unsigned long write_bandwidth; /* the estimated write bandwidth */
	unsigned long avg_write_bandwidth; /* further smoothed write bw, > 0 */
	...
}
```

write bandwidth estimation 算法更新一次 write bandwidth 的最小周期为 200ms (BANDWIDTH_INTERVAL)，以防止采样周期过小而引入的毛刺

执行 write bandwidth estimation 操作的入口有两个：

一个是在 writeback 过程中当回写 IO 下发完成时，就会更新 write bandwidth

```sh
wb_writeback
    # writeback sb's inodes
    writeback_sb_inodes
    
    wb_update_bandwidth
        __wb_update_bandwidth
```

另一个是 buffer write 路径中的 dirty throttle 也会触发 write bandwidth 的更新


```sh
balance_dirty_pages
    __wb_update_bandwidth
```

执行 write bandwidth estimation 具体操作的函数为 __wb_update_bandwidth()

```sh
__wb_update_bandwidth
    # elapsed = now - wb->bw_time_stamp
    # if elapsed > HZ, and wb->bw_time_stamp is before start_time
        # Skip quiet periods when disk bandwidth is under-utilized.
        # (at least 1s idle time between two flusher runs)
    
    wb_update_write_bandwidth
        elapsed = now - wb->bw_time_stamp
        written = percpu_counter_read(&wb->stat[WB_WRITTEN])
       
        # if current estimation window larger than 3s
        if elapsed > 3 * HZ:
            bw = (written - wb->written_stamp) * Hz / elapsed
            wb->write_bandwidth = bw
            wb->avg_write_bandwidth = bw
        
        else:
            # smooth wb->write_bandwidth,
            # and wb->avg_write_bandwidth
    
    # update wb->written_stamp and wb->bw_time_stamp
    wb->written_stamp = written;
    wb->bw_time_stamp = now;
```

wb->bw_time_stamp 描述上一次更新 write bandwidth 的时刻；wb->written_stamp 描述上一次更新 write bandwidth 时，缓存的 wb->stat[WB_WRITTEN] 计数器的值

因而这里通过 (wb->stat[WB_WRITTEN] - wb->written_stamp) 获取当前这个采样周期中完成回写的 page 的数量，通过 (jiffies - wb->bw_time_stamp) 计算当前这个采样周期已经过去的时间

如果当前 (jiffies - wb->bw_time_stamp) 的值，即当前这个采样周期已经过去的时间足够大，例如大于 3s，由于这个采样周期足够长、足以消除毛刺的影响，那么直接将以上两者相除，就得到新的 write_bandwidth 和 avg_write_bandwidth


##### dirty_rate

类似地，dirty_rate 描述过去一段时间系统中往某一个设备生产 dirty page 的带宽，即这些 dirty page 的 backing store 为对应的设备，后面这些 dirty page 需要回写到这个设备上；后面也用于描述 cgroup writeback 中对应 cgroup 的生产 dirty page 的带宽

> stat[WB_DIRTIED]

wb->stat[WB_DIRTIED] 计数器描述该 wb 生产的 dirty page 的数量

```c
struct bdi_writeback {
	struct percpu_counter stat[NR_WB_STAT_ITEMS];
	...
}
```

buffer write 路径中，就会更新该计数器的值

```
f_op->write_iter(kiocb, iov_iter)
    generic_perform_write
       a_ops->write_begin() // find buffer page in page cache
        iov_iter_copy_from_user_atomic // copy from user buffer to buffer page
        a_ops->write_end(), e.g., ext4_write_end // mark buffer page as dirty
            block_write_end
                __block_commit_write
                    mark_buffer_dirty
                        __set_page_dirty
                            __folio_mark_dirty
                                folio_account_dirtied
                                    nr = folio_nr_pages(folio)
                                    wb_stat_mod(wb, WB_DIRTIED, nr)
```


> dirty rate estimation

```c
struct bdi_writeback {
	unsigned long bw_time_stamp;	/* last time write bw is updated */
	unsigned long dirtied_stamp;
	...
}
```

dirty rate estimation 算法更新一次 dirty rate 的最小周期同样为 200ms (BANDWIDTH_INTERVAL)

操作的入口主要是在 buffer write 路径中 dirty throttle 的时候触发 dirty rate 的更新

```sh
balance_dirty_pages
    __wb_update_bandwidth
        elapsed = now - wb->bw_time_stamp
        dirtied = percpu_counter_read(&wb->stat[WB_DIRTIED]);
        
        wb_update_dirty_ratelimit(..., dirtied, elapsed)
            dirty_rate = (dirtied - wb->dirtied_stamp) * HZ / elapsed;
        
        wb->dirtied_stamp = dirtied;
        wb->bw_time_stamp = now
```



wb->bw_time_stamp 描述上一次更新 dirty rate 的时刻；wb->dirtied_stamp 描述上一次更新 dirty rate 时，缓存的 wb->stat[WB_DIRTIED] 计数器的值

因而这里通过 (wb->stat[WB_DIRTIED] - wb->dirtied_stamp) 获取当前这个采样周期中新产生的 dirty page 的数量，通过 (jiffies - wb->bw_time_stamp) 计算当前这个采样周期已经过去的时间，两者相除就得到新的即当前这个采样周期对应的 dirty rate


##### balanced_dirty_ratelimit

之前介绍过，`balanced_dirty_ratelimit` 描述一个进程以怎样的速度生产 dirty page，可以使得系统中 dirty page 的水平保持不变

在已知 write_bw 和 dirty_rate 的情况下，根据以下计算公式，就可以计算得到 balanced_dirty_ratelimit

```
                              write_bw
balanced_dirty_ratelimit *=  ----------                     (6)
                              dirty_rate
```

另外虽然 balanced_dirty_ratelimit 描述的是一个进程以怎样的速度生产 dirty page，可以使得系统中 dirty page 的水平保持不变，但是在 dirty throttle 实现中，是在 per-wb 范围内维护并更新 balanced_dirty_ratelimit 的

```c
struct bdi_writeback {
	unsigned long balanced_dirty_ratelimit;
	...
}
```

也就是说所有向这个设备执行写操作的进程，在触发 dirty throttle 的时候，使用的都是这个设备 (bdi->wb) 维护的 balanced_dirty_ratelimit 参数。那随着执行写操作的进程数量的增加，我们的预期是 balanced_dirty_ratelimit 的值应该变小 (因为随着进程数量的增加，每个进程分配到的生产 dirty page 的配额理应减小)。而这刚好能通过上述公式 (6) 描述的自适应算法实现，即当执行写操作的进程数量增加时，dirty_rate 参数值 (生产 dirty page 的速度) 增加，而 write_bw 参数值保持不变 (设备的能力是有限的，即设备的最大回写速度是一定的)，从而使得 (write_bw/dirty_rate) 得到一个小于 1 的系数，从而令 balanced_dirty_ratelimit 参数自适应地变小


另外后面会介绍到，dirty throttle 算法实际用于计算 pause time (即当前进程需要睡眠的时间) 的并不是 balanced_dirty_ratelimit，而是经过 pos_ratio 因子调整过后的 task_ratelimit，因而 wb->balanced_dirty_ratelimit 中存储的实际上是 pos_ratio 因子调整过后的 balanced_dirty_ratelimit，即

```
task_ratelimit = wb->dirty_ratelimit * pos_ratio;

                                             write_bw
balanced_dirty_ratelimit = task_ratelimit * ----------
                                             dirty_rate
```

其中 dirty_ratelimit 是 balanced_dirty_ratelimit 经过平滑处理后的值

```sh
balance_dirty_pages
    __wb_update_bandwidth
        wb_update_dirty_ratelimit
            write_bw = ...
            dirty_rate = ...
            task_ratelimit = wb->dirty_ratelimit * pos_ratio
                             >> RATELIMIT_CALC_SHIFT;
            wb->balanced_dirty_ratelimit = task_ratelimit *
                                           write_bw / dirty_rate;
```

上述使用上个采样周期的 dirty_ratelimit 计算得到 task_ratelimit，并最终计算得到当前采样周期下的 balanced_dirty_ratelimit


#### dirty_ratelimit

上述介绍的 balanced_dirty_ratelimit 描述了对于一个进程来说，进程以怎样的速度生产 dirty page，系统中 dirty page 的水平会保持不变，即保持在 setpoint 位置

balanced_dirty_ratelimit 的值由 write_bw 和 dirty_rate 参数决定，每隔 BANDWIDTH_INTERVAL 即 200ms 更新一次。balanced_dirty_ratelimit 的更新周期需要适当地小，从而使得 dirty throttle 算法保持足够灵敏的响应速度；但相对小的更新周期有时会导致个别周期下 balanced_dirty_ratelimit 的值发生跳变、或者是上下颠簸，在过滤掉这些跳变和随机误差，同时对 balanced_dirty_ratelimit 参数的值进行平滑处理之后，就得到了 `dirty_ratelimit`

```c
struct bdi_writeback {
	/*
	 * @dirty_ratelimit tracks the estimated @balanced_dirty_ratelimit
	 * in small steps and is much more smooth/stable than the latter.
	 */
	unsigned long dirty_ratelimit;
	...
}
```

dirty_ratelimit 会在 balanced_dirty_ratelimit 的基础上，变化地更加平滑

```sh
balance_dirty_pages
    __wb_update_bandwidth
        wb_update_dirty_ratelimit
            dirty_ratelimit = wb->dirty_ratelimit
            task_ratelimit = wb->dirty_ratelimit * pos_ratio
                             >> RATELIMIT_CALC_SHIFT;
            balanced_dirty_ratelimit = task_ratelimit *
                                       write_bw / dirty_rate;
            
            dirty_ratelimit = ... # calculate based on balanced_dirty_ratelimit
            wb->dirty_ratelimit = dirty_ratelimit
```

这里用到的几个参数，dirty_ratelimit 表示上个采样周期的 dirty_ratelimit；task_ratelimit 和 balanced_dirty_ratelimit 都是当前这个采样周期下的对应参数值

dirty_ratelimit 平滑处理的思想是，

1. 如果 dirty < setpoint 即当前系统中 dirty page 水位在 setpoint 以下，那么可以预期的是，dirty_ratelimit 肯定处于一个上升的趋势

a. 此时如果当前采样周期计算得到的最新的 balanced_dirty_ratelimit 小于上个采样周期的 dirty_ratelimit 值，那么就把当前采样周期的 balanced_dirty_ratelimit 作为一个跳变忽略，此时 dirty_ratelimit 保持上个采样周期的值不作更新

```
        current                     last                    
        balanced_dirty_ratelimit    dirty_ratelimit    
---------------+------------------------+---------------------
```

```
if dirty < setpoint:
    x = min3(wb->balanced_dirty_ratelimit,
             balanced_dirty_ratelimit, task_ratelimit);
    if (dirty_ratelimit > x)
        step = 0
    
    # dirty_ratelimit keep old value from last smapling period
    dirty_ratelimit -= step 
    wb->dirty_ratelimit = dirty_ratelimit
```


b. 而如果当前采样周期计算得到的最新的 balanced_dirty_ratelimit 大于上个采样周期的 dirty_ratelimit 值，那么说明 balanced_dirty_ratelimit 在正确的 (上升) 趋势上，此时会将当前采样周期下的 balanced_dirty_ratelimit 作为当前采样周期下新的 dirty_ratelimit 值，即 dirty_ratelimit 的值会增长，但是为了作平滑处理，dirty_ratelimit 增长的步长会按一定比例缩小

```
        last                    current
        dirty_ratelimit         balanced_dirty_ratelimit    
---------------+------------------------+---------------------
               |---------- step -------->
               
               step after smoothing
               |------->
                       ^
                    dirty_ratelimit after smoothing
```

```
if dirty < setpoint:
    x = min3(wb->balanced_dirty_ratelimit,
             balanced_dirty_ratelimit, task_ratelimit);
    if (dirty_ratelimit < x)
			step = x - dirty_ratelimit;

    # scale step by certain ratio
    shift = ...
    step = DIV_ROUND_UP(step >> shift, 8)
    
    dirty_ratelimit += step
    wb->dirty_ratelimit = dirty_ratelimit
```

2. 类似地，如果 dirty > setpoint 即当前系统中 dirty page 水位在 setpoint 以上，那么可以预期的是，dirty_ratelimit 肯定处于一个下降的趋势

a. 那么如果当前采样周期计算得到的最新的 balanced_dirty_ratelimit 大于上个采样周期的 dirty_ratelimit 值，那么就把当前采样周期的 balanced_dirty_ratelimit 作为一个跳变忽略，此时 dirty_ratelimit 保持上个采样周期的值不作更新

b. 而如果当前采样周期计算得到的最新的 balanced_dirty_ratelimit 小于上个采样周期的 dirty_ratelimit 值，那么说明 balanced_dirty_ratelimit 在正确的 (下降) 趋势上，此时会将当前采样周期下的 balanced_dirty_ratelimit 作为当前采样周期下新的 dirty_ratelimit 值，即 dirty_ratelimit 的值会下降，但是为了作平滑处理，dirty_ratelimit 下降的步长会按一定比例缩小


#### pos_ratio

以上计算得到的 balanced_dirty_ratelimit (或者说 dirty_ratelimit) 只能确保系统中 dirty page 的水平保持不变

如果当前系统中 dirty page 的水平已经超过了 setpoint，那么当前可用的 dirty_ratelimit 配额需要小于 balanced_dirty_ratelimit，使得 dirty page 回写的速度大于产生的速度，从而让系统中 dirty page 的水平降至 setpoint 水位

类似地，如果当前系统中 dirty page 的水平在 setpoint 以下，那么当前可用的 dirty_ratelimit 配额可以大于 balanced_dirty_ratelimit，使得 dirty page 回写的速度小于产生的速度，从而让系统中 dirty page 的水平回升至 setpoint 水位

此时需要使用一个参数对上述计算得到的 balance_dirty_pages 进行修正，以得到最后可用的 task_ratelimit，这个参数就称为 `pos_ratio`

```
task_ratelimit = wb->dirty_ratelimit * pos_ratio;
```

在 dirty throttle 过程中，就会将 dirty_ratelimit 乘以 pos_ratio 因子，最终得到 task_ratelimit 参数

```sh
balance_dirty_pages
    wb_position_ratio // calculate pos_ratio
    __wb_update_bandwidth
        wb_update_dirty_ratelimit
            task_ratelimit = wb->dirty_ratelimit * pos_ratio;
```


##### global control line

正如之前描述的，pos_ratio 应该是一个随着当前系统中 dirty page 的水平而动态变化的函数

- 当前系统中 dirty page 的水平在 setpoint 时，pos_ratio 应该为 1，此时系统中 dirty page 产生和回写的速度相当，从而使得系统中 dirty page 的水平保持在 setpoint 水位
- 当前系统中 dirty page 的水平大于 setpoint 时，pos_ratio 应该小于 1，使得 dirty page 回写的速度大于产生的速度，从而降低系统中 dirty page 的水平；同时 dirty page 水平越大，斜率应该越大，即 pos_ratio 下降地越快，从而达到快速抑制 dirty page 水平的目的
- 类似地，当前系统中 dirty page 的水平小于 setpoint 时，pos_ratio 应该大于 1，使得 dirty page 回写的速度小于产生的速度，从而抬升系统中 dirty page 的水平；同时 dirty page 水平越小，斜率应该越大，即 pos_ratio 上升地越快，从而达到快速抬升 dirty page 水平的目的


因而我们就得到了以下 pos_ratio 曲线

```
    ^ pos_ratio
    |
    |            |<===== global dirty control scope ======>|
2.0  * * * * * * *
    |            .*
    |            . *
    |            .   *
    |            .     *
    |            .        *
    |            .            *
1.0 ................................*
    |            .                  .     *
    |            .                  .          *
    |            .                  .              *
    |            .                  .                 *
    |            .                  .                    *
  0 +------------.------------------.----------------------*------------->
          freerun^          setpoint^                 limit^   dirty pages
```

实际上，pos_ratio 曲线是一个三次多项式函数

```
                   setpoint - dirty 3
f(dirty) := 1.0 + (----------------)
                   limit - setpoint
```

global control line 曲线具有以下特点：

> (1) f(freerun)  = 2.0 => rampup dirty_ratelimit reasonably fast
> (2) f(setpoint) = 1.0 => the balance point
> (3) f(limit)    = 0   => the hard limit
> (4) df/dx      <= 0	 => negative feedback control
> (5) the closer to setpoint, the smaller |df/dx| (and the reverse)
>     => fast response on large errors; small oscillation near setpoint


每次触发 dirty throttle 的时候都会根据上述公式，计算当前的 pos_ratio

```c
struct dirty_throttle_control {
	unsigned long		pos_ratio;
	...
}
```

```sh
balance_dirty_pages
    wb_position_ratio(gdtc)
        pos_ratio = pos_ratio_polynom() # calculate pos_ratio
```


##### wb control line

上述描述的 global control line 只能确保系统中全局的 dirty page 水平保持在全局的 setpoint (根据全局的 dirty_background_thresh/dirty_thresh 计算出来) 附近

而 pos_ratio 需要完成的另一项工作则是，当某个设备 (bdi->wb) 的 dirty page 水平超过了该设备的 setpoint 平衡点 (即该设备对应的 dirty page 的生产速度过快) 时，pos_ratio 应该小于 1，从而抑制生产该设备对应的 dirty page 的速度；类似地，当设备的 dirty page 水平在设备的 setpoint 平衡点以下 (即该设备对应的 dirty page 的生产速度很小) 时，pos_ratio 应该大于 1，从而允许更大的速度生产该设备对应的 dirty page

如果系统的内存规格较大，那么可能系统全局的 dirty page 仍保持在 free_run 水平，但是对于某一个特定的设备而言，生产 dirty page 的速度已经远远超过了该设备回写的速度，因而除了上述 global control line 以外，还需要引入 wb control line 以实现设备维度的写脏、回写平衡

也就是将上述 global control line 计算出来的 pos_ratio 再乘以一个系数，作为最终的 pos_ratio，这个系数也就是 wb control line 如下所示

```
    ^ pos_ratio
    |
    |            *
    |              *
    |                *
    |                  *
    |                    * |<=========== span ============>|
1.0 .......................*
    |                      . *
    |                      .   *
    |                      .     *
    |                      .       *
    |                      .         *
    |                      .           *
    |                      .             *
    |                      .               *
    |                      .                 *
    |                      .                   *
    |                      .                     *
1/4 ...............................................* * * * * * * * * * *
    |                      .                         .
    |                      .                           .
    |                      .                             .
  0 +----------------------.-------------------------------.------------>
               wb_setpoint^                    x_intercept^
```

wb control line 的起始部分是一个一次函数

```
f(wb_dirty) := 1.0 + k * (wb_dirty - wb_setpoint)

where "k = - 1 / (8 * write_bw)"
```

也就是说

```
                    wb_dirty - wb_setpoint
f(wb_dirty) := 1.0 - (----------------)
                        8 * write_bw
```

其中 write_bw 是整个系统中 dirty page 回写的速度，即回写带宽，参考 [title:'Writeback - 4 Dirty Throttle'](mweblib://16170860043979#write-bw-write-bandwidth)


###### wb_dirty

wb_dirty 描述该 bdi 设备中所有 dirty page 的数量，也就是当前这个设备 (wb) 中 WB_RECLAIMABLE 与 WB_WRITEBACK 类型的 page 数量之和

```c
struct dirty_throttle_control {
	unsigned long		wb_dirty;	/* per-wb counterparts */
	...
};
```

```sh
balance_dirty_pages
    wb_dirty_limits(gdtc)
        gdtc->wb_dirty = ... # calc number of this bdi's dirty pages (WB_RECLAIMABLE + WB_WRITEBACK)
```


###### wb_setpoint

wb_setpoint 是设备 (wb) 维度的 setpoint，其实际上是全局 setpoint 中每个设备 (wb) 的 setpoint 份额，其计算公式为

```
wb_setpoint = setpoint * gdtc->wb_thresh / gdtc->thresh
```

其中 setpoint 是全局的 setpoint，参考 [title:'Writeback - 4 Dirty Throttle'](mweblib://16170860043979#setpoint)


###### wb_thresh

wb_thresh 是设备 (wb) 维度的 thresh 阈值，也是 wb control line 实现设备维度的写脏、回写平衡的关键，其实际上是该设备 (wb) 在全局 dirty_thresh 中的配额 (以 PAGE_SIZE 为单位)，也就是分配给该设备 (wb) 的 write-back cache 配额

```c
struct dirty_throttle_control {
	unsigned long		wb_thresh;
	...
};
```

这里会根据该设备 (wb) 完成的回写量占整个系统回写量的百分比，计算该该设备 (wb) 在全局 dirty_thresh 中的配额，作为 wb_thresh

```sh
balance_dirty_pages
    wb_dirty_limits(gdtc)
        dtc->wb_thresh = __wb_calc_thresh(dtc)
            wb_thresh = thresh * wb->completions / dom->completions     
```

上述涉及两个 completions 计数

其中 @global_wb_domain->completions 计数保存全局的 completions 计数，系统全局每个 dirty page 成功完成回写的时候，都会增加该计数

此外每个设备 (wb) 自己也维护了一个 completions 计数，即 @wb->completions 计数，保存该设备 (wb) 自己完成回写的 dirty page 的数量，每个 dirty page 成功完成回写的时候，也会增加该计数

```sh
end_page_writeback
    test_clear_page_writeback
        __wb_writeout_inc
            wb_domain_writeout_inc(&global_wb_domain, &wb->completions, ...)
                # add global_wb_domain->completions
                # add wb->completions
```


这里需要注意的是 @completions 计数实际上是 struct fprop_local_percpu 数据类型，该数据类型专门用于统计计算各个事件之间的比例关系（例如上述的每个设备 (wb) 完成的回写量占整个系统回写量的百分比），该数据结构本身支持这一比例关系的周期更新，从而确保上述计算得到的回写量的百分比反映的是最近一段统计周期内的比例关系


例如全局的 global_wb_domain->completions 计数依赖于 timer 定时更新其 @completions 计数，更新周期即为 VM_COMPLETIONS_PERIOD_LEN 即 3s，每次更新周期就会将 @completions 计数清为 0

```
wb_domain_init(&global_wb_domain, ...)
    timer_setup(&dom->period_timer, writeout_period, ...)
```

```
writeout_period
    fprop_new_period
        # clear wb_domain->completions counter
    
    mod_timer
        # request for next timer schedule
```


此外对于 wb->completions 计数，在触发增加 completions 计数或计算比例的时候，当发现 global_wb_domain->completions 计数在不久前进入新的统计周期的时候，就会触发 wb->completions 计数进入新的统计周期

```
__wb_calc_thresh
    fprop_fraction_percpu
        fprop_reflect_period_percpu
            # clear wb->completions counter
```

```sh
end_page_writeback
    test_clear_page_writeback
        __wb_writeout_inc
            wb_domain_writeout_inc(&global_wb_domain, &wb->completions, ...)
                # add global_wb_domain->completions
                # add wb->completions

                fprop_reflect_period_percpu
                    # wb->completions counter
```



###### min_ratio/max_ratio

此外用户也可以通过 min_ratio/max_ratio 参数控制每个设备的 wb_thresh 在全局 dirty_thresh 中的百分比的下限与上限


min_ratio 参数描述该设备的 write-back cache 配额 (设备的 wb_thresh 在全局 dirty_thresh 中的百分比) 的下限，通常用于需要确保最低 QoS 的场景

用户可以通过 `/sys/class/bdi/<bdi>/min_ratio` 控制该参数


max_ratio 参数描述该设备的 write-back cache 配额 (设备的 wb_thresh 在全局 dirty_thresh 中的百分比) 的上限，以防止某个特定设备或文件系统抢占所有或绝大部分的 write-back cache 配额，例如 NFS 文件系统由于网络原因回写过程中可能经常发生卡顿、而导致 NFS 占用绝大部分 write-back cache 配额的情况下而又不能及时地回写；又或者 FUSE  这种用户态文件系统，作为不可信的文件系统，我们需要限制它们占用的 write-back cache 配额

用户可以通过 `/sys/class/bdi/<bdi>/max_ratio` 控制该参数

> min_ratio - allows one to assign a minimum portion of the write-back cache to a particular device.  This is useful in situations where you might want to provide a minimum QoS.  (One request for this feature came from flash based storage people who wanted to avoid writing out at all costs - they of course needed some pdflush hacks as well)
>
> max_ratio - allows one to assign a maximum portion of the dirty limit to a particular device.  This is useful in situations where you want to avoid one device taking all or most of the write-back cache.  Eg.  an NFS mount that is prone to get stuck, or a FUSE mount which you don't trust to play fair.
> 
> commit 189d3c4 ("mm: bdi: allow setting a minimum for the bdi dirty limit")

```sh
balance_dirty_pages
    wb_dirty_limits(gdtc)
        dtc->wb_thresh = __wb_calc_thresh(dtc)
            # calc this bdi's share of gdtc->thresh
            wb_thresh = thresh * wb->completions / dom->completions
            
            gdtc->wb_thresh can't exceed gdtc->thresh * bdi->max_ratio
            gdtc->wb_thresh is at least gdtc->thresh * bdi->min_ratio
```


#### task_ratelimit

`task_ratelimit` 表示每个进程经过 pos_ratio 调整后，可以生产 dirty page 的速度，根据以下公式

```
task_ratelimit = wb->dirty_ratelimit * pos_ratio;
```

就可以在 balanced_dirty_ratelimit 的基础上，经过 pos_ratio 修正，得到task_ratelimit，task_ratelimit 具有以下曲线

```
  ^ task rate limit
  |
  |            *
  |             *
  |              *
  |[free run]      *      [smooth throttled]
  |                  *
  |                     *
  |                         *
  ..bdi->dirty_ratelimit..........*
  |                               .     *
  |                               .          *
  |                               .              *
  |                               .                 *
  |                               .                    *
  +-------------------------------.-----------------------*------------>
                          setpoint^                  limit^  dirty pages
```


最终经 pos_ratio 修正后得到的 task_ratelimit 有

```sh
balance_dirty_pages
    wb_position_ratio  # calc pos_ratio
    
    __wb_update_bandwidth
        wb_update_dirty_ratelimit # calc dirty_ratelimit
    
    task_ratelimit = wb->dirty_ratelimit * pos_ratio
                     >> RATELIMIT_CALC_SHIFT;
```


#### pause time

在得到 task_ratelimit 之后，根据 balance_dirty_pages() 传入的 @pages_dirtied 参数，也就是当前一次写操作需要写入并置脏的 page 的数量，将其除以 task_ratelimit，就可以计算得到当前进程需要睡眠的时间，即 `pause time`

```
pause = HZ * pages_dirtied / task_ratelimit;
```

之后当前进程上下文就会进入 TASK_KILLABLE 状态睡眠一段时间 (@pause)

```sh
balance_dirty_pages
    for (;;) {
        pause = HZ * pages_dirtied / task_ratelimit;
        __set_current_state(TASK_KILLABLE);
        io_schedule_timeout(pause);
        ...
    }
```


上文介绍到，当 dirty 超过 thresh、或者 strictlimit 模式下 wb_dirty 超过 wb_thresh 的时候，pos_ratio 为 0，因而计算出来的 task_ratelimit 为 0，此时的 pause time 来自 max_pause

```sh
balance_dirty_pages
    max_pause = wb_max_pause(wb, sdtc->wb_dirty)
    
    if task_ratelimit == 0:
        period = max_pause;
			pause = max_pause;
```

#### complete

上述介绍到当触发 dirty throttle 的时候，进程就会睡眠一段时间 (pause_time)，之后如果满足以下条件，就会使得 balance_dirty_pages() 成功返回，之后进程就可以继续写入 dirty page；否则进程就会在 balance_dirty_pages() 中循环触发 dirty throttle 并睡眠

```sh
balance_dirty_pages
    for (;;) {
        pause = ...
        __set_current_state(TASK_KILLABLE);
        io_schedule_timeout(pause);
        
        if (task_ratelimit)
            break;
            
        if (sdtc->wb_dirty <= wb_stat_error())
            break;
        ...
    }
```

1. dirty < thresh

第一种情况是 task_ratelimit 恢复为正，由 pos_ratio 曲线可知，也就是当前 dirty < thresh，即 dirty page 的数量恢复到 thresh hardlimit 以下


2. permit through good bdi even when global dirty exceeded (if number of dirty pages is small enough)

> commit c5c6343 ("writeback: permit through good bdi even when global dirty exceeded")

另一种情况是，对于 NFS、FUSE 这种非本地文件系统，当 NFS server 或 FUSE daemon 故障停止服务 (无法回写)、或者响应很慢 (回写速度很慢) 的时候，就有可能导致本地全局的 dirty page 一直超过 thresh，从而导致本地的其他文件系统 (例如本地 ext4) 的进程也一直在 dirty throttle 流程中无法挣脱，而尽管该本地文件系统自身可能只有很少的 dirty page

对这个问题的 workaround 解决方案是，如果这个本地文件系统的 dirty page 数量 (即 wb_dirty) 足够小，那么即使当前全局 dirty page 的数量已经超过了 thresh hardlimit (即 task_ratelimit 仍为 0)，那么仍然允许进程脱离 dirty throttle，以保持该本地文件系统上的进程的响应；后续依赖于系统管理员将 thresh hardlimit 参数调大、或将 NFS/FUSE 文件系统的 writer 进程杀死，以扭转 dirty page 一直小于 thresh hardlimit 的局势

那么接下来就是确定这个"足够小的数"的数值。这一解法的核心思想相当于是给“本分”的文件系统预留一个“逃生通道”，即 pipe，在全局 dirty page 的数量已经超过 thresh hardlimit 的时候 (从而导致后续一直陷在 dirty throttle 循环)，仍然能够脱离 dirty throttle，从而防止这些文件系统的 writer 失去相应。

理论上这个 pipe 的大小只需要一个 page 就够了，即回写一个 page 之后，就允许新置脏一个 page，这能保证这些文件系统的 writer 保持最低程度的响应性。但是考虑到 wb_dirty 存在统计误差，因而这个 pipe 的大小放宽到 wb_stat_error()

在单处理器系统 (UP)，wb_stat_error() 的值就为 1；而在多处理器系统 (SMP)，wb_stat_error() 的值与 CPU 数量相关

```c
#define WB_STAT_BATCH (8*(1+ilog2(nr_cpu_ids)))

wb_stat_error
	return nr_cpu_ids * WB_STAT_BATCH;
```


#### strictlimit

dirty throttle 判断过程中会涉及两套参数

```c
struct dirty_throttle_control {
	unsigned long		dirty;		/* file_dirty + write + nfs */
	unsigned long		thresh;		/* dirty threshold */
	unsigned long		bg_thresh;	/* dirty background threshold */
	
	unsigned long		wb_dirty;	/* per-wb counterparts */
	unsigned long		wb_thresh;
	unsigned long		wb_bg_thresh;
	...
};
```

其中 @dirty/@thresh/@bg_thresh 是全局参数，描述系统所有 dirty page 的数量、全局的 background thresh 以及 thresh 参数

而 @wb_dirty/@wb_thresh/@wb_bg_thresh 则是 per-bdi (或者 per-cgroup，当 cgroup writeback 开启的时候) 的参数，分别描述该 bdi 设备 (或者 cgroup) 所有 dirty page 的数量，以及在全局 dirty_thresh/wb_bg_thresh 中的配额

上述 struct dirty_throttle_control 中保存的所有参数均以 PAGE_SIZE 为单位


在 IO-less Dirty Throttle 中，如之前描述的，当系统中 dirty page 的数量 (dirty) 超过 free_run 阈值时才会触发 dirty throttle，也就是让当前触发 throttle 的进程睡眠一段时间

这里 free_run 由 dirty_background_thresh、dirty_thresh 这两个参数计算得来

`free_run = (dirty_background_thresh + dirty_thresh) / 2`

```
          (background writeback)
  free run   |   free run    | soft throttle | hard throttle       
-------------+---------------+---------------+------------>
             ^               ^               ^          dirty pages
dirty_background_thresh     free_run         dirty_thresh
```

一般情况下，上述描述的 dirty page 的数量 (dirty)、以及 dirty_background_thresh、dirty_thresh 参数都是指全局参数，也就是当系统中所有 dirty page 的数量超过全局配置的 free_run 阈值时，才会触发 dirty throttle

```
balance_dirty_pages
    gdtc->dirty = ...
    domain_dirty_limits(gdtc)
        dtc->thresh = ...
        dtc->bg_thresh = ...
    
    dirty = gdtc->dirty;
    thresh = gdtc->thresh;
    bg_thresh = gdtc->bg_thresh;
    
    if dirty <= (thresh + bg_thresh) / 2 :
        # free_running
```


上面描述的 per-bdi (或者 per-cgroup) 的参数，即 @wb_dirty/@wb_thresh/@wb_bg_thresh 则只是在计算 pos_ratio 的时候参与 wb control line 的运算，即影响进程的 pause time；本身并不会影响是否触发 dirty throttle 的判断

因而这就导致有些文件系统 (例如非 root 挂载的 fuse 文件系统)，其单个文件系统就可以耗尽全局的 dirty page 配额，即全局的 dirty 参数都来自单个文件系统


v3.12 引入的 strictlimit 特性就用来解决这一问题 commit 5a53748 ("mm/page-writeback.c: add strictlimit feature")

开启 strictlimit 特性的文件系统需要在 bdi->capabilities 置上 BDI_CAP_STRICTLIMIT 标志


##### dirty thorttle condition

在开启 strictlimit 特性的时候，参与 dirty throttle 裁决的是 per-bdi (或者 per-cgroup) 的参数，即当前设备或者 cgroup 占用的 dirty page 数量超过该设备或者 cgroup 的相关配额时，就会触发 dirty throttle

```
balance_dirty_pages
    wb_dirty_limits(gdtc)
        wb_dirty_limits
            gdtc->wb_thresh = ... # calc this bdi's share of gdtc->thresh
                                    also considering min_ratio/max_ratio
            
            gdtc->wb_bg_thresh = ... # calc this bdi's share of gdtc->bg_thresh
                                    also considering min_ratio/max_ratio
            gdtc->wb_dirty = ... # calc number of this bdi's dirty pages (WB_RECLAIMABLE + WB_WRITEBACK)

    dirty = gdtc->wb_dirty;
    thresh = gdtc->wb_thresh;
    bg_thresh = gdtc->wb_bg_thresh;

    if dirty <= (thresh + bg_thresh) / 2 :
        # free_running
```

一般 bdi 创建出来的时候，min_ratio 的默认值为 0，max_ratio 的默认值为 100

但是 FUSE 中认为用户态文件系统不可信，因而默认开启 strictlimit 特性，同时 max_ratio 的初始值为 1，即默认只能用 1% 的 write-back cache 配额

```
fuse_bdi_init
    sb->s_bdi->capabilities |= BDI_CAP_STRICTLIMIT
    
	/*
	 * For a single fuse filesystem use max 1% of dirty +
	 * writeback threshold.
	 *
	 * This gives about 1M of write buffer for memory maps on a
	 * machine with 1G and 10% dirty_ratio, which should be more
	 * than enough.
	 *
	 * Privileged users can raise it by writing to
	 *
	 *    /sys/class/bdi/<bdi>/max_ratio
	 */
    bdi_set_max_ratio(sb->s_bdi, 1);
```


##### pos_ratio's wb control line

之前介绍过，在计算 pos_ratio 时 wb control line 会实现设备 (wb) 维度的写脏、回写平衡，而开启 strictlimit 特性时的 wb control line 与之前介绍的 wb control line 则存在差异

```
balance_dirty_pages
    wb_position_ratio(gdtc)
        # calc global control line
        pos_ratio = pos_ratio_polynom(setpoint, dirty, thresh)
        
        # calc wb control line under strictlimit
        if wb_dirty:
            [0, 8):
                pos_ratio = min(pos_ratio * 2, 2)
            [8, wb_thresh):
                wb_setpoint = dirty_freerun_ceiling(wb_thresh, wb_bg_thresh)
                wb_pos_ratio = pos_ratio_polynom(wb_setpoint, wb_dirty, wb_thresh)
                pos_ratio = min(pos_ratio, wb_pos_ratio)
            [wb_thresh, ∞):
                pos_ratio = 0
```


##### dirty_ratelimit

之前介绍过 balanced_dirty_ratelimit 描述了一个进程以怎样的速度生产 dirty page，系统中 dirty page 的水平会保持不变，即保持在 setpoint 位置；而 dirty_ratelimit 则是对 balanced_dirty_ratelimit 过滤掉一些采样周期下的跳变和随机误差、平滑处理之后的版本；dirty_ratelimit 用于计算 task_ratelimit，而 task_ratelimit 则正是用于计算进程的 pause time

在开启 strictlimit 特性的时候，dirty_ratelimit 的计算也会存在差异

之前介绍过在计算 dirty_ratelimit 的时候，会根据 dirty 在 setpoint 的左边/右边来判断当前预期的dirty_ratelimit 是处于上升还是下降趋势，从而在上述平滑处理的过程中采取相应的策略；上述使用的 dirty/setpoint 都是系统全局的概念，setpoint 也是由系统全局的 thresh、bg_thresh 计算而来

而在开启 strictlimit 特性的时候，使用的 dirty/setpoint 实际上都是 per-wb 的概念，使用的 dirty 实际上是 wb_dirty，即该设备 (wb) 的所有 dirty page 的数量，而 setpoint 也是由 wb_thresh、wb_bg_thresh 计算而来

```sh
balance_dirty_pages
    __wb_update_bandwidth
        wb_update_dirty_ratelimit
            balanced_dirty_ratelimit = ...
            
            dirty = dtc->wb_dirty
            if wb_dirty < 8:
                setpoint = wb_dirty + 1
            else:
                setpoint = (wb_thresh + wb_bg_thresh) / 2
```